from tkinter import *
import collections
import random
from itertools import product, combinations
import inspect
import copy

def are_sync(a, b, c):
    list_of_objects = sorted(set(a + b + c))
    if len(list_of_objects) == 3 and a != b and c != b and a != c:
        if a[0] in b and a[0] not in c and a[1] in c and a[1] not in b:
            return True
        elif a[0] not in b and a[0] in c and a[1] in b and a[1] not in c:
            return True
        else:
            return False
    else:
        return False

def are_sync_ext(a, b, c, d, e, f, t):
    if a[t] == c[t] and a[t] != e[t] and a[t] != f[t]:
        if b[t] == e[t] and b[t] != d[t] and d[0] == f[t]:
            return True
        elif b[t] == f[t] and b[t] != d[t] and d[t] == e[t]:
            return True
        else:
            return False
    elif a[t] == e[t] and a[t] != c[t] and a[t] != d[t]:
        if b[t] == c[t] and b[t] != f[t] and d[t] == f[t]:
            return True
        elif b[t] == d[t] and b[t] != f[t] and c[t] == f[t]:
            return True
        else:
            return False
    elif a[t] == d[t] and a[t] != e[t] and a[t] != f[t]:
        if b[t] == f[t] and c[t] != f[t] and c[t] == e[t]:
            return True
        else:
            return False
    elif a[t] == f[t] and a[t] != e[t] and a[0] != f[t]:
        if b[t] == d[t] and c[t] != f[t] and c[t] == e[t]:
            return True
        else:
            return False
    else:
        return False

def extract_coordinate_lines(col):
    rows = []
    columns = []
    for i in col:
        if i[0][0] not in rows:
            rows.append(i[0][0])
        if i[1][0] not in rows:
            rows.append(i[1][0])
        if i[0][1] not in columns:
            columns.append(i[0][1])
        if i[1][1] not in columns:
            columns.append(i[1][1])
    return [sorted(rows), sorted(columns)]


def update_up_for_x_winging(col, t):
    ncol = []
    if len(col) > 1:
        while True:
            extr_coords = extract_coordinate_lines(col)
            lines_more_than_one = []
            for line in extr_coords[1-t]:
                num_of_meet = 0
                a_lines = []
                for alt_line in extr_coords[t]:
                    for i in col:
                        for ij in i:
                            if ij[1-t] == line and ij[t] == alt_line:
                                num_of_meet += 1
                                a_lines.append(alt_line)
                if num_of_meet > 1:
                    lines_more_than_one.append(a_lines)
                elif num_of_meet == 1:
                    for k in col:
                        if k[0][1-t] == line or k[1][1-t] == line:
                            col.remove(k)
            if len(lines_more_than_one) == len(extr_coords[1-t]):
                break
    if len(col) > 3:
        for colu in range(len(col)-1):
            for cold in range(colu+1, len(col)):
                if col[colu][0][1-t] == col[cold][0][1-t] and col[colu][1][1-t] == col[cold][1][1-t]:
                    lines_num_of_meets = []
                    for line in [col[colu][0][1-t], col[colu][0][1-t]]:
                        num_of_meets = 0
                        for alt_line in extr_coords[t]:
                            for i in col:
                                for ij in i:
                                    if ij[1-t] == line and ij[t] == alt_line:
                                        num_of_meets += 1
                        lines_num_of_meets.append(num_of_meets)
                    if (lines_num_of_meets[0] == 2 and lines_num_of_meets[1] >= 2) or (lines_num_of_meets[0] >= 2 and lines_num_of_meets[1] == 2):
                        ncol.append([col[colu], col[cold]])
        unappended = col
        for hj in ncol:
            if hj[0] in unappended:
                unappended.remove(hj[0])
            if hj[1] in unappended:
                unappended.remove(hj[1])
        if len(unappended) > 0:
            ncol.append(unappended)
    else:
        ncol = [col]
    return ncol

class Sudoku_main_work:
    def __init__(self):
        self.starting_widgets_solving_mode()

    def reset_all(self):
        for widget in tk.winfo_children():
            widget.destroy()
        self.starting_widgets_solving_mode()

    def reset_all_build_mode(self):
        for widget in tk.winfo_children():
            widget.destroy()
        self.starting_widgets_building_mode()

    def starting_widgets_solving_mode(self):
        self.enter_numbers_solving_mode = []
        for k in range(81):
            self.enter_numbers_solving_mode.append(Entry(tk, font = ("Calibri", 30), justify = "center"))
            self.enter_numbers_solving_mode[-1].place(x = 5+(k -(k//9)*9)*55, y =  5+(k//9)*55, width = 50, height = 50 )
        self.solve_button_solving_mode = Button(tk, text = "Solve", command = self.solve_sudoku)
        self.solve_button_solving_mode.place(x = 500, y =  445, width = 180, height = 50 )
        self.to_building_mode = Button(tk, text = "Building Mode", command = self.reset_all_build_mode)
        self.to_building_mode.place(x = 500, y =  5, width = 180, height = 50 )
        self.reset_button_solving_mode = Button(tk, text = "Reset", command = self.reset_all)
        self.reset_button_solving_mode.place(x = 500, y =  390, width = 180, height = 50 )

    def starting_widgets_building_mode(self):
        self.difficulty_evaluation = "hints"
        self.enter_numbers_building_mode = []
        for k in range(81):
            self.enter_numbers_building_mode.append(Entry(tk, font = ("Calibri", 30), justify = "center"))
            self.enter_numbers_building_mode[-1].place(x = 5+(k -(k//9)*9)*55, y =  5+(k//9)*55, width = 50, height = 50 )
        self.enter_number_of_hints_building_mode = (Entry(tk, font = ("Calibri", 15), justify = "center"))
        self.enter_number_of_hints_building_mode.place(x = 640, y = 355, width = 40, height = 30 )
        self.build_button_building_mode = Button(tk, text = "Build", command = self.build_sudoku)
        self.build_button_building_mode.place(x = 500, y =  445, width = 87, height = 50 )
        self.diff_button_building_mode = Button(tk, text = "Hints (17-80):", command = self.change_diff_evaluation)
        self.diff_alt_button_building_mode = Button(tk, text = "Difficulty (1-3):", command = self.change_diff_evaluation)
        self.diff_button_building_mode.place(x = 500, y =  355, width = 135, height = 30 )
        self.generate_button_building_mode = Button(tk, text = "Generate", command = self.generate_sudoku)
        self.generate_button_building_mode.place(x = 592, y =  445, width = 87, height = 50 )
        self.to_solving_mode = Button(tk, text = "Solving Mode", command = self.reset_all)
        self.to_solving_mode.place(x = 500, y =  5, width = 180, height = 50 )
        self.reset_button_building_mode = Button(tk, text = "Reset", command = self.reset_all_build_mode)
        self.reset_button_building_mode.place(x = 500, y =  390, width = 180, height = 50 )

    def change_diff_evaluation(self):
        if self.difficulty_evaluation == "hints":
            self.diff_button_building_mode.place_forget()
            self.diff_alt_button_building_mode.place(x = 500, y =  355, width = 135, height = 30 )
            self.difficulty_evaluation = "levels"
        elif self.difficulty_evaluation == "levels":
            self.diff_alt_button_building_mode.place_forget()
            self.diff_button_building_mode.place(x = 500, y =  355, width = 135, height = 30 )
            self.difficulty_evaluation = "hints"

    def create_empty_sudoku_table(self):
        self.sudoku_table = []
        for n in range(9):
            empty_row = []
            for k in range(9):
                empty_row.append([1, 2, 3, 4, 5, 6, 7, 8, 9])
            self.sudoku_table.append(empty_row)

    def solve_sudoku(self, ww=-1, numw=0, gen=0):
        self.called_by = str(inspect.stack()[1].function)
        if self.called_by != "sudoku_solve_branched":
            self.uses = {"Naked Singles": 0, "Hidden Singles": 0,
                         "Naked Quad": 0, "Hidden Quad": 0,
                         "Naked Quint": 0, "Hidden Quint": 0,
                         "Naked Pair": 0, "Hidden Pair": 0,
                         "Naked Triplet": 0, "Hidden Triplet": 0,
                         "Blockades": 0, "X-wings": 0, "Y-wings": 0,
                         "Swordfishing": 0, "Jellyfishing": 0,
                         "Starfishing": 0, "Skyscrapering": 0, "XYZ-wings": 0}
            self.list_of_changes_solving_mode = []
            self.action = 1
            self.create_empty_sudoku_table()
            self.branches_limit_countdown = 0
            self.moderate, self.comprehanded = False, False
            difficulty = "easy"
        else:
            difficulty = "hard"
        self.solvability, self.iters, self.solved = "possible", 0, False
        if self.called_by == "__call__":
            for k in range(81):
                temp = self.enter_numbers_solving_mode[k].get()
                if len(temp)>1:
                    self.solvability = "impossible"
                    reason = "Invalid values!"
                    break
                elif len(temp) == 1:
                    try:
                        self.asign_cell_num(k//9, k%9, temp, "as a hint")
                    except:
                        pass
        elif self.called_by == "build_cell_by_cell" or self.called_by == "build_cell_by_cell_alt":
            tables_iden = copy.deepcopy(self.sudoku_table_build)
            for k in range(81):
                temp = str(tables_iden[k//9][k%9])
                if len(temp)>1:
                    self.solvability = "impossible"
                    reason = "Invalid values!"
                    break
                elif len(temp) == 1:
                    try:
                        self.asign_cell_num(k//9, k%9, temp, "as a hint")
                    except:
                        pass
        elif self.called_by == "sudoku_solve_branched":
            self.asign_cell_num(ww//9, ww%9, numw, "as a hint")
        else:
            self.solvability = "impossible"
            reason = "Unknown mode!"
        while self.solvability == "possible":
            self.solve_by_easy_methods()
            if self.solvability == "possible":
                allowed_n = False
                for kn in range(81):
                    if str(type(copy.deepcopy(self.sudoku_table)[kn//9][kn%9]))=="<class 'list'>":
                        allowed_n = True
                        if difficulty == "easy":
                            difficulty = "normal"
                        break
                if allowed_n:
                    self.ch_gl = False
                    self.solve_by_normal_methods()
                    if self.solvability == "possible":
                        allowed_h = False
                        for km in range(81):
                            if str(type(copy.deepcopy(self.sudoku_table)[km//9][km%9]))=="<class 'list'>":
                                if self.called_by  == "build_cell_by_cell_alt":
                                    if int(self.enter_number_of_hints_building_mode.get()) <= 2:
                                        self.solvability = "impossible"
                                    else:
                                        allowed_h = True
                                        if difficulty != "hard":
                                            difficulty = "hard"
                                else:
                                    allowed_h = True
                                    if difficulty != "hard":
                                        difficulty = "hard"
                                break
                        if allowed_h:
                            self.solved = False
                            self.sudoku_solve_branched(gen)
                        else:
                            self.solved = True
                            break
                else:
                    self.solved = True
                    break
        if self.solvability == "impossible":
            difficulty = "impossible"
            self.solved = False
        if self.called_by == "__call__": #and self.solved:
            temp_text_widget = Text(tk, wrap="word")
            temp_text_widget.place(x = 5, y =  505, width = 665, height = 200 )
            scrollbar = Scrollbar(tk, command=temp_text_widget.yview)
            temp_text_widget.config(yscrollcommand=scrollbar.set)
            scrollbar.place(x=670, y=505, height=200)
            temp_label = Label(tk, text = f"Difficulty: {difficulty}", bg = "black", fg = "white", font=("Calibri", 10))
            temp_label.place(x = 500, y =  355, width = 200, height = 30 )
            items = ""
            for item in self.list_of_changes_solving_mode:
                temp_text_widget.insert(END, item + "\n")
            temp_text_widget.insert(END, f"Difficulty evaluated as {difficulty}\n")
            for item in self.uses:
                temp_text_widget.insert(END, f"{item}: {self.uses[item]}\n")
        elif (self.called_by == "build_cell_by_cell" or self.called_by == "build_cell_by_cell_alt") and self.solved:
            temp_text_widget = Text(tk, wrap="word")
            temp_text_widget.place(x = 5, y =  505, width = 665, height = 200 )
            scrollbar = Scrollbar(tk, command=temp_text_widget.yview)
            temp_text_widget.config(yscrollcommand=scrollbar.set)
            scrollbar.place(x=670, y=505, height=200)
            temp_text_widget.insert(END, f"Step: {self.h}, Difficulty evaluated as {difficulty}\n")
            if int(self.enter_number_of_hints_building_mode.get()) <= 1 and difficulty != "easy":
                temp_text_widget.insert(END, f"Step: {self.h+1}, Difficulty evaluated as easy\n")
            for item in self.uses:
                temp_text_widget.insert(END, f"{item}: {self.uses[item]}\n")
        self.difficulty = difficulty
            

    def solve_by_easy_methods(self):
        self.ch_in_basics = True
        while self.solvability == "possible" and self.ch_in_basics:
            self.ch_in_basics = False
            if self.solvability == "possible":
                self.look_for_one_possible_number()
            if self.solvability == "possible":
                self.look_for_hidden_one()

    def solve_by_normal_methods(self):
        self.moderate = True
        while self.solvability == "possible" and self.moderate:
            self.moderate, self.ch_gl = False, False
            if self.solvability == "possible":
                self.solve_by_easy_methods()
                if self.ch_gl:
                    self.moderate = True
            if self.solvability == "possible":
                self.look_for_blockades()
            if self.solvability == "possible":
                self.x_wing()
            if self.solvability == "possible":
                self.y_wing()
            if self.solvability == "possible":
                self.sword_fish_ext()
            if self.solvability == "possible":
                self.jellyfish()
            if self.solvability == "possible":
                self.starfish()
            if self.solvability == "possible":
                self.skyscraper()
            if self.solvability == "possible":
                self.pairs_and_triples()
            if self.solvability == "possible":
                self.quads_and_quints()


    def sudoku_solve_branched(self, g):
        self.branches_limit_countdown += 1
        if ((self.called_by == "build_cell_by_cell" or self.called_by == "build_cell_by_cell_alt") and self.branches_limit_countdown < 50 and g < 4) or ((self.called_by == "__call__" or self.called_by == "sudoku_solve_branched") and self.branches_limit_countdown < 100 and g < 5):
            if g == 0:
                self.called_by_on_first_gen = self.called_by
            if self.solvability == "possible":
                successes = []
                for k in range(81):
                    if str(type(self.sudoku_table[k//9][k%9]))=="<class 'list'>":
                        sudoku_table_original = copy.deepcopy(self.sudoku_table)
                        for i in range(len(sudoku_table_original[k//9][k%9])):
                            self.sudoku_table = copy.deepcopy(sudoku_table_original)
                            self.solve_sudoku(k, copy.deepcopy(self.sudoku_table[k//9][k%9])[i], gen = g+1)
                            if self.solved:
                                successes.append([k//9, k%9, sudoku_table_original[k//9][k%9][i]])
                            self.solvability, self.solved = "possible", False
                        self.sudoku_table = copy.deepcopy(sudoku_table_original)
                        break
                if len(successes) == 1:
                    if g == 0:
                        self.called_by = self.called_by_on_first_gen
                    self.asign_cell_num(successes[0][0], successes[0][1], successes[0][2], "as a one possible branched solution")
                    self.ch_gl = True
                    self.comprehanded = True
                elif len(successes) > 1 or (len(successes) != 1 and g == 0):
                    self.solvability = "impossible"
            else:
                self.solved = False
        else:
            self.solvability = "impossible"
                
                    
    def look_for_one_possible_number(self):
        table_changed = True
        while table_changed and self.solvability == "possible":
            table_changed = False
            for k in range(81):
                if str(type(self.sudoku_table[k//9][k%9]))=="<class 'list'>":
                    if len(self.sudoku_table[k//9][k%9])==0:
                        if self.called_by == "__call__":
                            print("Sudoku is unsolvable!")
                        self.solvability = "impossible"
                        break
                    elif len(self.sudoku_table[k//9][k%9])==1:
                        self.asign_cell_num(k//9, k%9, int(self.sudoku_table[k//9][k%9][0]), "as one possible number")
                        table_changed, self.ch_gl, self.ch_in_basics = True, True, True
                        self.uses["Naked Singles"] += 1

    def look_for_hidden_one(self):
        table_changed = True
        while table_changed and self.solvability == "possible":
            table_changed = False
            for k in range(1, 10):
                for r in range(9):
                    cells  = []
                    for m in range(9):
                        if str(type(self.sudoku_table[r][m]))=="<class 'list'>":
                            if k in self.sudoku_table[r][m]:
                                cells.append([r, m])
                    if len(cells) == 1:
                        self.asign_cell_num(cells[0][0], cells[0][1], k, f"as one possible in a row {r+1}")
                        table_changed, self.ch_gl, self.ch_in_basics = True, True, True
                        self.uses["Hidden Singles"] += 1
                    elif len(cells) == 0:
                        allowed = False
                        for mch in range(9):
                            if str(type(self.sudoku_table[r][mch]))=="<class 'int'>":
                                if k == self.sudoku_table[r][mch]:
                                    allowed = True
                                    break
                        if not allowed:
                            self.solvability = "impossible"
                for c in range(9):
                    cells  = []
                    for n in range(9):
                        if str(type(self.sudoku_table[n][c]))=="<class 'list'>":
                            if k in self.sudoku_table[n][c]:
                                cells.append([n, c])
                    if len(cells) == 1:
                        self.asign_cell_num(cells[0][0], cells[0][1], k, f"as one possible in a collumn {self.letter_for_collumn(c)}")
                        table_changed, self.ch_gl, self.ch_in_basics = True, True, True
                        self.uses["Hidden Singles"] += 1
                    elif len(cells) == 0:
                        allowed = False
                        for nch in range(9):
                            if str(type(self.sudoku_table[nch][c]))=="<class 'int'>":
                                if k == self.sudoku_table[nch][c]:
                                    allowed = True
                                    break
                        if not allowed:
                            self.solvability = "impossible"
                for b in range(9):
                    cells  = []
                    for f in range(9):
                        if str(type(self.sudoku_table[((b//3)*3)+(f//3)][((b%3)*3)+(f%3)]))=="<class 'list'>":
                            if k in self.sudoku_table[((b//3)*3)+(f//3)][((b%3)*3)+(f%3)]:
                                cells.append([int(((b//3)*3)+(f//3)), int(((b%3)*3)+(f%3))])
                    if len(cells) == 1:
                        self.asign_cell_num(cells[0][0], cells[0][1], k, f"as one possible in a block #{b+1}")
                        table_changed, self.ch_gl, self.ch_in_basics = True, True, True
                        self.uses["Hidden Singles"] += 1
                    elif len(cells) == 0:
                        allowed = False
                        for fch in range(9):
                            if str(type(self.sudoku_table[((b//3)*3)+(fch//3)][((b%3)*3)+(fch%3)]))=="<class 'int'>":
                                if k == self.sudoku_table[((b//3)*3)+(fch//3)][((b%3)*3)+(fch%3)]:
                                    allowed = True
                                    break
                        if not allowed:
                            self.solvability = "impossible"

    def look_for_blockades(self):
        table_changed = True
        while table_changed and self.solvability == "possible":
            table_changed = False
            for b in range(9):
                for k in range(1, 10):
                    line_1, line_2, line_3, line_a, line_b, line_c = 0, 0, 0, 0, 0, 0
                    for i in range(3):
                        for j in range(3):
                            if str(type(self.sudoku_table[((b//3)*3)+i][((b%3)*3)+j]))=="<class 'list'>":
                                if k in self.sudoku_table[((b//3)*3)+i][((b%3)*3)+j]:
                                    if i == 0:
                                        line_1 += 1
                                    elif i == 1:
                                        line_2 += 1
                                    elif i == 2:
                                        line_3 += 1
                                    if j == 0:
                                        line_a += 1
                                    elif j == 1:
                                        line_b += 1
                                    elif j == 2:
                                        line_c += 1
                    blockade_horizontal_line, blockade_vertical_line = "no", "no"
                    if line_1 > 1 and line_2 == 0 and line_3 == 0:
                        blockade_horizontal_line = 0
                    elif line_1 == 0 and line_2 > 1 and line_3 == 0:
                        blockade_horizontal_line = 1
                    elif line_1 == 0 and line_2 == 0 and line_3 > 1:
                        blockade_horizontal_line = 2
                    if str(type(blockade_horizontal_line))=="<class 'int'>":
                        for l in range(9):
                            if str(type(self.sudoku_table[((b//3)*3)+blockade_horizontal_line][l]))=="<class 'list'>" and l not in [(b%3)*3, ((b%3)*3)+1, ((b%3)*3)+2]:
                                if k in self.sudoku_table[((b//3)*3)+blockade_horizontal_line][l]:
                                    self.sudoku_table[((b//3)*3)+blockade_horizontal_line][l].remove(int(k))
                                    self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {k} from list of p.n. in cell {self.letter_for_collumn(l)}{((b//3)*3)+blockade_horizontal_line+1} (due to blockade in block #{b+1} horizontaly)")
                                    self.action += 1
                                    table_changed, self.ch_gl, self.moderate = True, True, True
                                    self.uses["Blockades"] += 1
                    if line_a > 1 and line_b == 0 and line_c == 0:
                        blockade_vertical_line = 0
                    elif line_a == 0 and line_b > 1 and line_c == 0:
                        blockade_vertical_line = 1
                    elif line_a == 0 and line_b == 0 and line_c > 1:
                        blockade_vertical_line = 2
                    if str(type(blockade_vertical_line))=="<class 'int'>":
                        for g in range(9):
                            if str(type(self.sudoku_table[g][((b%3)*3)+blockade_vertical_line]))=="<class 'list'>" and g not in [(b//3)*3, ((b//3)*3)+1, ((b//3)*3)+2]:
                                if k in self.sudoku_table[g][((b%3)*3)+blockade_vertical_line]:
                                    self.sudoku_table[g][((b%3)*3)+blockade_vertical_line].remove(int(k))
                                    self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {k} from list of p.n. in cell {self.letter_for_collumn(((b%3)*3)+blockade_vertical_line)}{g+1} (due to blockade in block #{b+1} verticaly)")
                                    self.action += 1
                                    table_changed, self.ch_gl, self.moderate = True, True, True
                                    self.uses["Blockades"] += 1
            for b1 in range(8):
                for b2 in range(b1 + 1, 9):
                    if not (b1 // 3 == b2 // 3) and not (b1 % 3 == b2 % 3):
                        break
                    for k in range(1, 10):
                        if (b1 // 3 == b2 // 3):
                            lines = [0]*3
                            lines2 = [0]*3
                            for r in range(3):
                                for c in [3*(b1 % 3), 3*(b1 % 3) + 1, 3*(b1 % 3) + 2]:
                                    if str(type(self.sudoku_table[(b1 // 3)*3+r][c]))=="<class 'list'>":
                                        if k in self.sudoku_table[(b1 // 3)*3+r][c]:
                                            lines[r] += 1
                            for r in range(3):
                                for c in [3*(b2 % 3), 3*(b2 % 3) + 1, 3*(b2 % 3) + 2]:
                                    if str(type(self.sudoku_table[(b2 // 3)*3+r][c]))=="<class 'list'>":
                                        if k in self.sudoku_table[(b2 // 3)*3+r][c]:
                                            lines2[r] += 1
                            allowed = False
                            if lines[0] == 0 and lines[1] > 0 and lines[2] > 0 and lines2[0] == 0 and lines2[1] > 0 and lines2[2] > 0:
                                rn = [(b1 // 3)*3+1, (b1 // 3)*3+2]
                                allowed = True
                            elif lines[0] > 0 and lines[1] == 0 and lines[2] > 0 and lines2[0] > 0 and lines2[1] == 0 and lines2[2] > 0:
                                rn = [(b1 // 3)*3, (b1 // 3)*3+2]
                                allowed = True
                            elif lines[0] > 0 and lines[1] > 0 and lines[2] == 0 and lines2[0] > 0 and lines2[1] > 0 and lines2[2] == 0:
                                rn = [(b1 // 3)*3, (b1 // 3)*3+1]
                                allowed = True
                            if allowed:
                                for r in rn:
                                    for g in sorted(list(set(list(range(9)))-set([3*(b1 % 3), 3*(b1 % 3) + 1, 3*(b1 % 3) + 2, 3*(b2 % 3), 3*(b2 % 3) + 1, 3*(b2 % 3) + 2]))):
                                        if str(type(self.sudoku_table[r][g]))=="<class 'list'>":
                                            if k in self.sudoku_table[r][g]:
                                                self.sudoku_table[r][g].remove(int(k))
                                                self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {k} from list of p.n. in cell {self.letter_for_collumn(g)}{r+1} (due to blockade in blocks #{b1+1} and {b2+1} horizontaly)")
                                                self.action += 1
                                                table_changed, self.ch_gl, self.moderate = True, True, True
                                                self.uses["Blockades"] += 1
                        if (b1 % 3 == b2 % 3):
                            lines = [0]*3
                            lines2 = [0]*3
                            for c in range(3):
                                for r in [3*(b1 // 3), 3*(b1 // 3) + 1, 3*(b1 // 3) + 2]:
                                    if str(type(self.sudoku_table[r][(b1 % 3)*3+c]))=="<class 'list'>":
                                        if k in self.sudoku_table[r][(b1 % 3)*3+c]:
                                            lines[c] += 1
                            for c in range(3):
                                for r in [3*(b2 // 3), 3*(b2 // 3) + 1, 3*(b2 // 3) + 2]:
                                    if str(type(self.sudoku_table[r][(b2 % 3)*3+c]))=="<class 'list'>":
                                        if k in self.sudoku_table[r][(b2 % 3)*3+c]:
                                            lines2[c] += 1
                            allowed = False
                            if lines[0] == 0 and lines[1] > 0 and lines[2] > 0 and lines2[0] == 0 and lines2[1] > 0 and lines2[2] > 0:
                                cn = [(b1 % 3)*3+1, (b1 % 3)*3+2]
                                allowed = True
                            elif lines[0] > 0 and lines[1] == 0 and lines[2] > 0 and lines2[0] > 0 and lines2[1] == 0 and lines2[2] > 0:
                                cn = [(b1 % 3)*3, (b1 % 3)*3+2]
                                allowed = True
                            elif lines[0] > 0 and lines[1] > 0 and lines[2] == 0 and lines2[0] > 0 and lines2[1] > 0 and lines2[2] == 0:
                                cn = [(b1 % 3)*3, (b1 % 3)*3+1]
                                allowed = True
                            if allowed:
                                for c in cn:
                                    for g in sorted(list(set(list(range(9)))-set([3*(b1 // 3), 3*(b1 // 3) + 1, 3*(b1 // 3) + 2, 3*(b2 // 3), 3*(b2 // 3) + 1, 3*(b2 // 3) + 2]))):
                                        if str(type(self.sudoku_table[g][c]))=="<class 'list'>":
                                            if k in self.sudoku_table[g][c]:
                                                self.sudoku_table[g][c].remove(int(k))
                                                self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {k} from list of p.n. in cell {self.letter_for_collumn(c)}{g+1} (due to blockade in blocks #{b1+1} and {b2+1} verticaly)")
                                                self.action += 1
                                                table_changed, self.ch_gl, self.moderate = True, True, True
                                                self.uses["Blockades"] += 1
            
    def pairs_and_triples(self):
        table_changed = True
        while table_changed and self.solvability == "possible":
            table_changed = False
            for b in range(9):
                list_of_cand_b = [0] * 9
                for k in range(9):
                    for i, j in product(range(3), repeat=2):
                        if str(type(self.sudoku_table[(b//3)*3 + i][(b%3)*3 + j])) == "<class 'list'>":
                            if k+1 in self.sudoku_table[(b//3)*3 + i][(b%3)*3 + j]:
                                list_of_cand_b[k] += 1
                for lu, lm, ld in combinations([i for i in range(9) if 2 <= list_of_cand_b[i] <= 3], 3):
                    num_of_structure = [lu+1, lm+1, ld+1]
                    cells_of_structure = []
                    for i, j in product(range(3), repeat=2):
                        cell = ((b//3)*3 + i, (b%3)*3 + j)
                        if str(type(self.sudoku_table[cell[0]][cell[1]])) == "<class 'list'>":
                            intersec = sorted(set(self.sudoku_table[cell[0]][cell[1]]) & set(num_of_structure))
                            if len(intersec) > 0:
                                cells_of_structure.append([cell[0], cell[1], intersec])
                    if len(cells_of_structure) == 3:
                        for cell in cells_of_structure:
                            if len(self.sudoku_table[cell[0]][cell[1]]) > len(cell[2]):
                                self.sudoku_table[cell[0]][cell[1]] = cell[2]
                                self.list_of_changes_solving_mode.append(f"#{self.action} --- Reduced to {cell[2]} in cell {self.letter_for_collumn(cell[1])}{cell[0]+1} (hidden triplet in block #{b+1})")
                                self.action += 1
                                table_changed = self.ch_gl = self.moderate = True
                                self.uses["Hidden Triplet"] += 1

                list_of_nums_cand_b = [0] * 9
                for i, j in product(range(3), repeat=2):
                    cell = ((b//3)*3 + i, (b%3)*3 + j)
                    if str(type(self.sudoku_table[cell[0]][cell[1]])) == "<class 'list'>":
                        list_of_nums_cand_b[3*i + j] = len(self.sudoku_table[cell[0]][cell[1]])
                
                for lu, lm, ld in combinations([i for i in range(9) if 2 <= list_of_nums_cand_b[i] <= 3], 3):
                    cells = [((b//3)*3 + lu//3, (b%3)*3 + lu%3), ((b//3)*3 + lm//3, (b%3)*3 + lm%3), ((b//3)*3 + ld//3, (b%3)*3 + ld%3)]
                    union = set()
                    for cell in cells:
                        union.update(self.sudoku_table[cell[0]][cell[1]])
                    if len(union) == 3:
                        for i, j in product(range(3), repeat=2):
                            cell = ((b//3)*3 + i, (b%3)*3 + j)
                            if cell not in cells and str(type(self.sudoku_table[cell[0]][cell[1]])) == "<class 'list'>":
                                new_values = [x for x in self.sudoku_table[cell[0]][cell[1]] if x not in union]
                                if len(new_values) < len(self.sudoku_table[cell[0]][cell[1]]):
                                    self.sudoku_table[cell[0]][cell[1]] = new_values
                                    self.list_of_changes_solving_mode.append(f"#{self.action} --- Reduced to {new_values} in cell {self.letter_for_collumn(cell[1])}{cell[0]+1} (obvious triplet in block #{b+1})")
                                    self.action += 1
                                    table_changed = self.ch_gl = self.moderate = True
                                    self.uses["Naked Triplet"] += 1
                                    
                list_of_cand_b = [0] * 9
                for k in range(9):
                    for i, j in product(range(3), repeat=2):
                        if str(type(self.sudoku_table[(b//3)*3 + i][(b%3)*3 + j])) == "<class 'list'>":
                            if k+1 in self.sudoku_table[(b//3)*3 + i][(b%3)*3 + j]:
                                list_of_cand_b[k] += 1
                for lu, ld in combinations([i for i in range(9) if list_of_cand_b[i] == 2], 2):
                    num_of_structure = [lu+1, ld+1]
                    cells_of_structure = []
                    for i, j in product(range(3), repeat=2):
                        cell = ((b//3)*3 + i, (b%3)*3 + j)
                        if str(type(self.sudoku_table[cell[0]][cell[1]])) == "<class 'list'>":
                            intersec = sorted(set(self.sudoku_table[cell[0]][cell[1]]) & set(num_of_structure))
                            if len(intersec) > 0:
                                cells_of_structure.append([cell[0], cell[1], intersec])
                    if len(cells_of_structure) == 2:
                        for cell in cells_of_structure:
                            if len(self.sudoku_table[cell[0]][cell[1]]) > len(cell[2]):
                                self.sudoku_table[cell[0]][cell[1]] = cell[2]
                                self.list_of_changes_solving_mode.append(f"#{self.action} --- Reduced to {cell[2]} in cell {self.letter_for_collumn(cell[1])}{cell[0]+1} (hidden pair in block #{b+1})")
                                self.action += 1
                                table_changed = self.ch_gl = self.moderate = True
                                self.uses["Hidden Pair"] += 1

                list_of_nums_cand_b = [0] * 9
                for i, j in product(range(3), repeat=2):
                    cell = ((b//3)*3 + i, (b%3)*3 + j)
                    if str(type(self.sudoku_table[cell[0]][cell[1]])) == "<class 'list'>":
                        list_of_nums_cand_b[3*i + j] = len(self.sudoku_table[cell[0]][cell[1]])
                
                for lu, ld in combinations([i for i in range(9) if list_of_nums_cand_b[i] == 2], 2):
                    cells = [((b//3)*3 + lu//3, (b%3)*3 + lu%3), ((b//3)*3 + ld//3, (b%3)*3 + ld%3)]
                    union = set()
                    for cell in cells:
                        union.update(self.sudoku_table[cell[0]][cell[1]])
                    if len(union) == 2:
                        for i, j in product(range(3), repeat=2):
                            cell = ((b//3)*3 + i, (b%3)*3 + j)
                            if cell not in cells and str(type(self.sudoku_table[cell[0]][cell[1]])) == "<class 'list'>":
                                new_values = [x for x in self.sudoku_table[cell[0]][cell[1]] if x not in union]
                                if len(new_values) < len(self.sudoku_table[cell[0]][cell[1]]):
                                    self.sudoku_table[cell[0]][cell[1]] = new_values
                                    self.list_of_changes_solving_mode.append(f"#{self.action} --- Reduced to {new_values} in cell {self.letter_for_collumn(cell[1])}{cell[0]+1} (obvious pair in block #{b+1})")
                                    self.action += 1
                                    table_changed = self.ch_gl = self.moderate = True
                                    self.uses["Naked Pair"] += 1
            for c in range(9):
                list_of_cand_b = [0] * 9
                for k in range(9):
                    for i in range(9):
                        if str(type(self.sudoku_table[i][c])) == "<class 'list'>":
                            if k+1 in self.sudoku_table[i][c]:
                                list_of_cand_b[k] += 1
                for lu, lm, ld in combinations([i for i in range(9) if 2 <= list_of_cand_b[i] <= 3], 3):
                    num_of_structure = [lu+1, lm+1, ld+1]
                    cells_of_structure = []
                    for i in range(9):
                        cell = (i, c)
                        if str(type(self.sudoku_table[cell[0]][cell[1]])) == "<class 'list'>":
                            intersec = sorted(set(self.sudoku_table[cell[0]][cell[1]]) & set(num_of_structure))
                            if len(intersec) > 0:
                                cells_of_structure.append([cell[0], cell[1], intersec])
                    if len(cells_of_structure) == 3:
                        for cell in cells_of_structure:
                            if len(self.sudoku_table[cell[0]][cell[1]]) > len(cell[2]):
                                self.sudoku_table[cell[0]][cell[1]] = cell[2]
                                self.list_of_changes_solving_mode.append(f"#{self.action} --- Reduced to {cell[2]} in cell {self.letter_for_collumn(cell[1])}{cell[0]+1} (hidden triplet in collumn #{c+1})")
                                self.action += 1
                                table_changed = self.ch_gl = self.moderate = True
                                self.uses["Hidden Triplet"] += 1

                list_of_nums_cand_b = [0] * 9
                for i in range(9):
                    cell = (i, c)
                    if str(type(self.sudoku_table[cell[0]][cell[1]])) == "<class 'list'>":
                        list_of_nums_cand_b[i] = len(self.sudoku_table[cell[0]][cell[1]])
                
                for lu, lm, ld in combinations([i for i in range(9) if 2 <= list_of_nums_cand_b[i] <= 3], 3):
                    cells = [(lu, c), (lm, c), (ld, c)]
                    union = set()
                    for cell in cells:
                        union.update(self.sudoku_table[cell[0]][cell[1]])
                    if len(union) == 3:
                        for i in range(9):
                            cell = (i, c)
                            if cell not in cells and str(type(self.sudoku_table[cell[0]][cell[1]])) == "<class 'list'>":
                                new_values = [x for x in self.sudoku_table[cell[0]][cell[1]] if x not in union]
                                if len(new_values) < len(self.sudoku_table[cell[0]][cell[1]]):
                                    self.sudoku_table[cell[0]][cell[1]] = new_values
                                    self.list_of_changes_solving_mode.append(f"#{self.action} --- Reduced to {new_values} in cell {self.letter_for_collumn(cell[1])}{cell[0]+1} (obvious triplet collumn #{c+1})")
                                    self.action += 1
                                    table_changed = self.ch_gl = self.moderate = True
                                    self.uses["Naked Triplet"] += 1

                list_of_cand_b = [0] * 9
                for k in range(9):
                    for i in range(9):
                        if str(type(self.sudoku_table[i][c])) == "<class 'list'>":
                            if k+1 in self.sudoku_table[i][c]:
                                list_of_cand_b[k] += 1
                for lu, ld in combinations([i for i in range(9) if list_of_cand_b[i] == 2], 2):
                    num_of_structure = [lu+1, ld+1]
                    cells_of_structure = []
                    for i in range(9):
                        cell = (i, c)
                        if str(type(self.sudoku_table[cell[0]][cell[1]])) == "<class 'list'>":
                            intersec = sorted(set(self.sudoku_table[cell[0]][cell[1]]) & set(num_of_structure))
                            if len(intersec) > 0:
                                cells_of_structure.append([cell[0], cell[1], intersec])
                    if len(cells_of_structure) == 2:
                        for cell in cells_of_structure:
                            if len(self.sudoku_table[cell[0]][cell[1]]) > len(cell[2]):
                                self.sudoku_table[cell[0]][cell[1]] = cell[2]
                                self.list_of_changes_solving_mode.append(f"#{self.action} --- Reduced to {cell[2]} in cell {self.letter_for_collumn(cell[1])}{cell[0]+1} (hidden pair in collumn #{c+1})")
                                self.action += 1
                                table_changed = self.ch_gl = self.moderate = True
                                self.uses["Hidden Pair"] += 1

                list_of_nums_cand_b = [0] * 9
                for i in range(9):
                    cell = (i, c)
                    if str(type(self.sudoku_table[cell[0]][cell[1]])) == "<class 'list'>":
                        list_of_nums_cand_b[i] = len(self.sudoku_table[cell[0]][cell[1]])
                
                for lu, ld in combinations([i for i in range(9) if list_of_nums_cand_b[i] == 2], 2):
                    cells = [(lu, c), (ld, c)]
                    union = set()
                    for cell in cells:
                        union.update(self.sudoku_table[cell[0]][cell[1]])
                    if len(union) == 2:
                        for i in range(9):
                            cell = (i, c)
                            if cell not in cells and str(type(self.sudoku_table[cell[0]][cell[1]])) == "<class 'list'>":
                                new_values = [x for x in self.sudoku_table[cell[0]][cell[1]] if x not in union]
                                if len(new_values) < len(self.sudoku_table[cell[0]][cell[1]]):
                                    self.sudoku_table[cell[0]][cell[1]] = new_values
                                    self.list_of_changes_solving_mode.append(f"#{self.action} --- Reduced to {new_values} in cell {self.letter_for_collumn(cell[1])}{cell[0]+1} (obvious pair collumn #{c+1})")
                                    self.action += 1
                                    table_changed = self.ch_gl = self.moderate = True
                                    self.uses["Naked Pair"] += 1
            for r in range(9):
                list_of_cand_b = [0] * 9
                for k in range(9):
                    for i in range(9):
                        if str(type(self.sudoku_table[r][i])) == "<class 'list'>":
                            if k+1 in self.sudoku_table[r][i]:
                                list_of_cand_b[k] += 1
                for lu, lm, ld in combinations([i for i in range(9) if 2 <= list_of_cand_b[i] <= 3], 3):
                    num_of_structure = [lu+1, lm+1, ld+1]
                    cells_of_structure = []
                    for i in range(9):
                        cell = (r, i)
                        if str(type(self.sudoku_table[cell[0]][cell[1]])) == "<class 'list'>":
                            intersec = sorted(set(self.sudoku_table[cell[0]][cell[1]]) & set(num_of_structure))
                            if len(intersec) > 0:
                                cells_of_structure.append([cell[0], cell[1], intersec])
                    if len(cells_of_structure) == 3:
                        for cell in cells_of_structure:
                            if len(self.sudoku_table[cell[0]][cell[1]]) > len(cell[2]):
                                self.sudoku_table[cell[0]][cell[1]] = cell[2]
                                self.list_of_changes_solving_mode.append(f"#{self.action} --- Reduced to {cell[2]} in cell {self.letter_for_collumn(cell[1])}{cell[0]+1} (hidden triplet in row #{r+1})")
                                self.action += 1
                                table_changed = self.ch_gl = self.moderate = True
                                self.uses["Hidden Triplet"] += 1

                list_of_nums_cand_b = [0] * 9
                for i in range(9):
                    cell = (r, i)
                    if str(type(self.sudoku_table[cell[0]][cell[1]])) == "<class 'list'>":
                        list_of_nums_cand_b[i] = len(self.sudoku_table[cell[0]][cell[1]])
                
                for lu, lm, ld in combinations([i for i in range(9) if 2 <= list_of_nums_cand_b[i] <= 3], 3):
                    cells = [(r, lu), (r, lm), (r, ld)]
                    union = set()
                    for cell in cells:
                        union.update(self.sudoku_table[cell[0]][cell[1]])
                    if len(union) == 3:
                        for i in range(9):
                            cell = (r, i)
                            if cell not in cells and str(type(self.sudoku_table[cell[0]][cell[1]])) == "<class 'list'>":
                                new_values = [x for x in self.sudoku_table[cell[0]][cell[1]] if x not in union]
                                if len(new_values) < len(self.sudoku_table[cell[0]][cell[1]]):
                                    self.sudoku_table[cell[0]][cell[1]] = new_values
                                    self.list_of_changes_solving_mode.append(f"#{self.action} --- Reduced to {new_values} in cell {self.letter_for_collumn(cell[1])}{cell[0]+1} (obvious triplet in row #{r+1})")
                                    self.action += 1
                                    table_changed = self.ch_gl = self.moderate = True
                                    self.uses["Naked Triplet"] += 1
                                    
                list_of_cand_b = [0] * 9
                for k in range(9):
                    for i in range(9):
                        if str(type(self.sudoku_table[r][i])) == "<class 'list'>":
                            if k+1 in self.sudoku_table[r][i]:
                                list_of_cand_b[k] += 1
                for lu, ld in combinations([i for i in range(9) if list_of_cand_b[i] == 2], 2):
                    num_of_structure = [lu+1, ld+1]
                    cells_of_structure = []
                    for i in range(9):
                        cell = (r, i)
                        if str(type(self.sudoku_table[cell[0]][cell[1]])) == "<class 'list'>":
                            intersec = sorted(set(self.sudoku_table[cell[0]][cell[1]]) & set(num_of_structure))
                            if len(intersec) > 0:
                                cells_of_structure.append([cell[0], cell[1], intersec])
                    if len(cells_of_structure) == 2:
                        for cell in cells_of_structure:
                            if len(self.sudoku_table[cell[0]][cell[1]]) > len(cell[2]):
                                self.sudoku_table[cell[0]][cell[1]] = cell[2]
                                self.list_of_changes_solving_mode.append(f"#{self.action} --- Reduced to {cell[2]} in cell {self.letter_for_collumn(cell[1])}{cell[0]+1} (hidden pair in row #{r+1})")
                                self.action += 1
                                table_changed = self.ch_gl = self.moderate = True
                                self.uses["Hidden Pair"] += 1

                list_of_nums_cand_b = [0] * 9
                for i in range(9):
                    cell = (r, i)
                    if str(type(self.sudoku_table[cell[0]][cell[1]])) == "<class 'list'>":
                        list_of_nums_cand_b[i] = len(self.sudoku_table[cell[0]][cell[1]])
                
                for lu, ld in combinations([i for i in range(9) if list_of_nums_cand_b[i] == 2], 2):
                    cells = [(r, lu), (r, ld)]
                    union = set()
                    for cell in cells:
                        union.update(self.sudoku_table[cell[0]][cell[1]])
                    if len(union) == 2:
                        for i in range(9):
                            cell = (r, i)
                            if cell not in cells and str(type(self.sudoku_table[cell[0]][cell[1]])) == "<class 'list'>":
                                new_values = [x for x in self.sudoku_table[cell[0]][cell[1]] if x not in union]
                                if len(new_values) < len(self.sudoku_table[cell[0]][cell[1]]):
                                    self.sudoku_table[cell[0]][cell[1]] = new_values
                                    self.list_of_changes_solving_mode.append(f"#{self.action} --- Reduced to {new_values} in cell {self.letter_for_collumn(cell[1])}{cell[0]+1} (obvious pair in row #{r+1})")
                                    self.action += 1
                                    table_changed = self.ch_gl = self.moderate = True
                                    self.uses["Naked Pair"] += 1

    def quads_and_quints(self):
        table_changed = True
        while table_changed and self.solvability == "possible":
            table_changed = False
            for b in range(9):
                list_of_cand_b = [0] * 9
                for k in range(9):
                    for i, j in product(range(3), repeat=2):
                        if str(type(self.sudoku_table[(b//3)*3 + i][(b%3)*3 + j])) == "<class 'list'>":
                            if k+1 in self.sudoku_table[(b//3)*3 + i][(b%3)*3 + j]:
                                list_of_cand_b[k] += 1
                for lu, lm, ln, ld in combinations([i for i in range(9) if 2 <= list_of_cand_b[i] <= 4], 4):
                    num_of_structure = [lu+1, lm+1, ln+1, ld+1]
                    cells_of_structure = []
                    for i, j in product(range(3), repeat=2):
                        cell = ((b//3)*3 + i, (b%3)*3 + j)
                        if str(type(self.sudoku_table[cell[0]][cell[1]])) == "<class 'list'>":
                            intersec = sorted(set(self.sudoku_table[cell[0]][cell[1]]) & set(num_of_structure))
                            if len(intersec) > 0:
                                cells_of_structure.append([cell[0], cell[1], intersec])
                    if len(cells_of_structure) == 4:
                        for cell in cells_of_structure:
                            if len(self.sudoku_table[cell[0]][cell[1]]) > len(cell[2]):
                                self.sudoku_table[cell[0]][cell[1]] = cell[2]
                                self.list_of_changes_solving_mode.append(f"#{self.action} --- Reduced to {cell[2]} in cell {self.letter_for_collumn(cell[1])}{cell[0]+1} (hidden quad in block #{b+1})")
                                self.action += 1
                                table_changed = self.ch_gl = self.moderate = True
                                self.uses["Hidden Quad"] += 1

                list_of_nums_cand_b = [0] * 9
                for i, j in product(range(3), repeat=2):
                    cell = ((b//3)*3 + i, (b%3)*3 + j)
                    if str(type(self.sudoku_table[cell[0]][cell[1]])) == "<class 'list'>":
                        list_of_nums_cand_b[3*i + j] = len(self.sudoku_table[cell[0]][cell[1]])
                for lu, lm, ln, ld in combinations([i for i in range(9) if 2 <= list_of_nums_cand_b[i] <= 4], 4):
                    cells = [((b//3)*3 + lu//3, (b%3)*3 + lu%3), ((b//3)*3 + lm//3, (b%3)*3 + lm%3), ((b//3)*3 + ln//3, (b%3)*3 + ln%3), ((b//3)*3 + ld//3, (b%3)*3 + ld%3)]
                    union = set()
                    for cell in cells:
                        union.update(self.sudoku_table[cell[0]][cell[1]])
                    if len(union) == 4:
                        for i, j in product(range(3), repeat=2):
                            cell = ((b//3)*3 + i, (b%3)*3 + j)
                            if cell not in cells and str(type(self.sudoku_table[cell[0]][cell[1]])) == "<class 'list'>":
                                new_values = [x for x in self.sudoku_table[cell[0]][cell[1]] if x not in union]
                                if len(new_values) < len(self.sudoku_table[cell[0]][cell[1]]):
                                    self.sudoku_table[cell[0]][cell[1]] = new_values
                                    self.list_of_changes_solving_mode.append(f"#{self.action} --- Reduced to {new_values} in cell {self.letter_for_collumn(cell[1])}{cell[0]+1} (obvious quad in block #{b+1})")
                                    self.action += 1
                                    table_changed = self.ch_gl = self.moderate = True
                                    self.uses["Naked Quad"] += 1
                                    
                list_of_cand_b = [0] * 9
                for k in range(9):
                    for i, j in product(range(3), repeat=2):
                        if str(type(self.sudoku_table[(b//3)*3 + i][(b%3)*3 + j])) == "<class 'list'>":
                            if k+1 in self.sudoku_table[(b//3)*3 + i][(b%3)*3 + j]:
                                list_of_cand_b[k] += 1               
                for lu, lm, ln, lo, ld in combinations([i for i in range(9) if 2 <= list_of_cand_b[i] <= 5], 5):
                    num_of_structure = [lu+1, lm+1, ln+1, lo+1, ld+1]
                    cells_of_structure = []
                    for i, j in product(range(3), repeat=2):
                        cell = ((b//3)*3 + i, (b%3)*3 + j)
                        if str(type(self.sudoku_table[cell[0]][cell[1]])) == "<class 'list'>":
                            intersec = sorted(set(self.sudoku_table[cell[0]][cell[1]]) & set(num_of_structure))
                            if len(intersec) > 0:
                                cells_of_structure.append([cell[0], cell[1], intersec])
                    if len(cells_of_structure) == 5:
                        for cell in cells_of_structure:
                            if len(self.sudoku_table[cell[0]][cell[1]]) > len(cell[2]):
                                self.sudoku_table[cell[0]][cell[1]] = cell[2]
                                self.list_of_changes_solving_mode.append(f"#{self.action} --- Reduced to {cell[2]} in cell {self.letter_for_collumn(cell[1])}{cell[0]+1} (hidden quint in block #{b+1})")
                                self.action += 1
                                table_changed = self.ch_gl = self.moderate = True
                                self.uses["Hidden Quint"] += 1

                list_of_nums_cand_b = [0] * 9
                for i, j in product(range(3), repeat=2):
                    cell = ((b//3)*3 + i, (b%3)*3 + j)
                    if str(type(self.sudoku_table[cell[0]][cell[1]])) == "<class 'list'>":
                        list_of_nums_cand_b[3*i + j] = len(self.sudoku_table[cell[0]][cell[1]])
                for lu, lm, ln, lo, ld in combinations([i for i in range(9) if 2 <= list_of_nums_cand_b[i] <= 5], 5):
                    cells = [((b//3)*3 + lu//3, (b%3)*3 + lu%3), ((b//3)*3 + lm//3, (b%3)*3 + lm%3), ((b//3)*3 + ln//3, (b%3)*3 + ln%3), ((b//3)*3 + lo//3, (b%3)*3 + lo%3), ((b//3)*3 + ld//3, (b%3)*3 + ld%3)]
                    union = set()
                    for cell in cells:
                        union.update(self.sudoku_table[cell[0]][cell[1]])
                    if len(union) == 5:
                        for i, j in product(range(3), repeat=2):
                            cell = ((b//3)*3 + i, (b%3)*3 + j)
                            if cell not in cells and str(type(self.sudoku_table[cell[0]][cell[1]])) == "<class 'list'>":
                                new_values = [x for x in self.sudoku_table[cell[0]][cell[1]] if x not in union]
                                if len(new_values) < len(self.sudoku_table[cell[0]][cell[1]]):
                                    self.sudoku_table[cell[0]][cell[1]] = new_values
                                    self.list_of_changes_solving_mode.append(f"#{self.action} --- Reduced to {new_values} in cell {self.letter_for_collumn(cell[1])}{cell[0]+1} (obvious quint in block #{b+1})")
                                    self.action += 1
                                    table_changed = self.ch_gl = self.moderate = True
                                    self.uses["Naked Quint"] += 1
            for c in range(9):
                list_of_cand_b = [0] * 9
                for k in range(9):
                    for i in range(9):
                        if str(type(self.sudoku_table[i][c])) == "<class 'list'>":
                            if k+1 in self.sudoku_table[i][c]:
                                list_of_cand_b[k] += 1
                for lu, lm, ln, ld in combinations([i for i in range(9) if 2 <= list_of_cand_b[i] <= 4], 4):
                    num_of_structure = [lu+1, lm+1, ln+1, ld+1]
                    cells_of_structure = []
                    for i in range(9):
                        cell = (i, c)
                        if str(type(self.sudoku_table[cell[0]][cell[1]])) == "<class 'list'>":
                            intersec = sorted(set(self.sudoku_table[cell[0]][cell[1]]) & set(num_of_structure))
                            if len(intersec) > 0:
                                cells_of_structure.append([cell[0], cell[1], intersec])
                    if len(cells_of_structure) == 4:
                        for cell in cells_of_structure:
                            if len(self.sudoku_table[cell[0]][cell[1]]) > len(cell[2]):
                                self.sudoku_table[cell[0]][cell[1]] = cell[2]
                                self.list_of_changes_solving_mode.append(f"#{self.action} --- Reduced to {cell[2]} in cell {self.letter_for_collumn(cell[1])}{cell[0]+1} (hidden quad in collumn #{c+1})")
                                self.action += 1
                                table_changed = self.ch_gl = self.moderate = True
                                self.uses["Hidden Quad"] += 1

                list_of_nums_cand_b = [0] * 9
                for i in range(9):
                    cell = (i, c)
                    if str(type(self.sudoku_table[cell[0]][cell[1]])) == "<class 'list'>":
                        list_of_nums_cand_b[i] = len(self.sudoku_table[cell[0]][cell[1]])
                
                for lu, lm, ln, ld in combinations([i for i in range(9) if 2 <= list_of_nums_cand_b[i] <= 4], 4):
                    cells = [(lu, c), (lm, c), (ln, c), (ld, c)]
                    union = set()
                    for cell in cells:
                        union.update(self.sudoku_table[cell[0]][cell[1]])
                    if len(union) == 4:
                        for i in range(9):
                            cell = (i, c)
                            if cell not in cells and str(type(self.sudoku_table[cell[0]][cell[1]])) == "<class 'list'>":
                                new_values = [x for x in self.sudoku_table[cell[0]][cell[1]] if x not in union]
                                if len(new_values) < len(self.sudoku_table[cell[0]][cell[1]]):
                                    self.sudoku_table[cell[0]][cell[1]] = new_values
                                    self.list_of_changes_solving_mode.append(f"#{self.action} --- Reduced to {new_values} in cell {self.letter_for_collumn(cell[1])}{cell[0]+1} (obvious quad collumn #{c+1})")
                                    self.action += 1
                                    table_changed = self.ch_gl = self.moderate = True
                                    self.uses["Naked Quad"] += 1

                list_of_cand_b = [0] * 9
                for k in range(9):
                    for i in range(9):
                        if str(type(self.sudoku_table[i][c])) == "<class 'list'>":
                            if k+1 in self.sudoku_table[i][c]:
                                list_of_cand_b[k] += 1
                for lu, lm, ln, lo, ld in combinations([i for i in range(9) if 2 <= list_of_cand_b[i] <= 5], 5):
                    num_of_structure = [lu+1, lm+1, ln+1, lo+1, ld+1]
                    cells_of_structure = []
                    for i in range(9):
                        cell = (i, c)
                        if str(type(self.sudoku_table[cell[0]][cell[1]])) == "<class 'list'>":
                            intersec = sorted(set(self.sudoku_table[cell[0]][cell[1]]) & set(num_of_structure))
                            if len(intersec) > 0:
                                cells_of_structure.append([cell[0], cell[1], intersec])
                    if len(cells_of_structure) == 5:
                        for cell in cells_of_structure:
                            if len(self.sudoku_table[cell[0]][cell[1]]) > len(cell[2]):
                                self.sudoku_table[cell[0]][cell[1]] = cell[2]
                                self.list_of_changes_solving_mode.append(f"#{self.action} --- Reduced to {cell[2]} in cell {self.letter_for_collumn(cell[1])}{cell[0]+1} (hidden quint in collumn #{c+1})")
                                self.action += 1
                                table_changed = self.ch_gl = self.moderate = True
                                self.uses["Hidden Quint"] += 1

                list_of_nums_cand_b = [0] * 9
                for i in range(9):
                    cell = (i, c)
                    if str(type(self.sudoku_table[cell[0]][cell[1]])) == "<class 'list'>":
                        list_of_nums_cand_b[i] = len(self.sudoku_table[cell[0]][cell[1]])
                
                for lu, lm, ln, lo, ld in combinations([i for i in range(9) if 2 <= list_of_nums_cand_b[i] <= 5], 5):
                    cells = [(lu, c), (lm, c), (ln, c), (lo, c), (ld, c)]
                    union = set()
                    for cell in cells:
                        union.update(self.sudoku_table[cell[0]][cell[1]])
                    if len(union) == 5:
                        for i in range(9):
                            cell = (i, c)
                            if cell not in cells and str(type(self.sudoku_table[cell[0]][cell[1]])) == "<class 'list'>":
                                new_values = [x for x in self.sudoku_table[cell[0]][cell[1]] if x not in union]
                                if len(new_values) < len(self.sudoku_table[cell[0]][cell[1]]):
                                    self.sudoku_table[cell[0]][cell[1]] = new_values
                                    self.list_of_changes_solving_mode.append(f"#{self.action} --- Reduced to {new_values} in cell {self.letter_for_collumn(cell[1])}{cell[0]+1} (obvious quint collumn #{c+1})")
                                    self.action += 1
                                    table_changed = self.ch_gl = self.moderate = True
                                    self.uses["Naked Quint"] += 1
                                    
            for r in range(9):
                list_of_cand_b = [0] * 9
                for k in range(9):
                    for i in range(9):
                        if str(type(self.sudoku_table[r][i])) == "<class 'list'>":
                            if k+1 in self.sudoku_table[r][i]:
                                list_of_cand_b[k] += 1
                for lu, lm, ln, ld in combinations([i for i in range(9) if 2 <= list_of_cand_b[i] <= 4], 4):
                    num_of_structure = [lu+1, lm+1, ln+1, ld+1]
                    cells_of_structure = []
                    for i in range(9):
                        cell = (r, i)
                        if str(type(self.sudoku_table[cell[0]][cell[1]])) == "<class 'list'>":
                            intersec = sorted(set(self.sudoku_table[cell[0]][cell[1]]) & set(num_of_structure))
                            if len(intersec) > 0:
                                cells_of_structure.append([cell[0], cell[1], intersec])
                    if len(cells_of_structure) == 4:
                        for cell in cells_of_structure:
                            if len(self.sudoku_table[cell[0]][cell[1]]) > len(cell[2]):
                                self.sudoku_table[cell[0]][cell[1]] = cell[2]
                                self.list_of_changes_solving_mode.append(f"#{self.action} --- Reduced to {cell[2]} in cell {self.letter_for_collumn(cell[1])}{cell[0]+1} (hidden quad in row #{r+1})")
                                self.action += 1
                                table_changed = self.ch_gl = self.moderate = True
                                self.uses["Hidden Quad"] += 1

                list_of_nums_cand_b = [0] * 9
                for i in range(9):
                    cell = (r, i)
                    if str(type(self.sudoku_table[cell[0]][cell[1]])) == "<class 'list'>":
                        list_of_nums_cand_b[i] = len(self.sudoku_table[cell[0]][cell[1]])
                
                for lu, lm, ln, ld in combinations([i for i in range(9) if 2 <= list_of_nums_cand_b[i] <= 4], 4):
                    cells = [(r, lu), (r, lm), (r, ln), (r, ld)]
                    union = set()
                    for cell in cells:
                        union.update(self.sudoku_table[cell[0]][cell[1]])
                    if len(union) == 4:
                        for i in range(9):
                            cell = (r, i)
                            if cell not in cells and str(type(self.sudoku_table[cell[0]][cell[1]])) == "<class 'list'>":
                                new_values = [x for x in self.sudoku_table[cell[0]][cell[1]] if x not in union]
                                if len(new_values) < len(self.sudoku_table[cell[0]][cell[1]]):
                                    self.sudoku_table[cell[0]][cell[1]] = new_values
                                    self.list_of_changes_solving_mode.append(f"#{self.action} --- Reduced to {new_values} in cell {self.letter_for_collumn(cell[1])}{cell[0]+1} (obvious quad in row #{r+1})")
                                    self.action += 1
                                    table_changed = self.ch_gl = self.moderate = True
                                    self.uses["Naked Quad"] += 1

                list_of_cand_b = [0] * 9
                for k in range(9):
                    for i in range(9):
                        if str(type(self.sudoku_table[r][i])) == "<class 'list'>":
                            if k+1 in self.sudoku_table[r][i]:
                                list_of_cand_b[k] += 1
                for lu, lm, ln, lo, ld in combinations([i for i in range(9) if 2 <= list_of_cand_b[i] <= 5], 5):
                    num_of_structure = [lu+1, lm+1, ln+1, lo+1, ld+1]
                    cells_of_structure = []
                    for i in range(9):
                        cell = (r, i)
                        if str(type(self.sudoku_table[cell[0]][cell[1]])) == "<class 'list'>":
                            intersec = sorted(set(self.sudoku_table[cell[0]][cell[1]]) & set(num_of_structure))
                            if len(intersec) > 0:
                                cells_of_structure.append([cell[0], cell[1], intersec])
                    if len(cells_of_structure) == 5:
                        for cell in cells_of_structure:
                            if len(self.sudoku_table[cell[0]][cell[1]]) > len(cell[2]):
                                self.sudoku_table[cell[0]][cell[1]] = cell[2]
                                self.list_of_changes_solving_mode.append(f"#{self.action} --- Reduced to {cell[2]} in cell {self.letter_for_collumn(cell[1])}{cell[0]+1} (hidden quint in row #{r+1})")
                                self.action += 1
                                table_changed = self.ch_gl = self.moderate = True
                                self.uses["Hidden Quint"] += 1

                list_of_nums_cand_b = [0] * 9
                for i in range(9):
                    cell = (r, i)
                    if str(type(self.sudoku_table[cell[0]][cell[1]])) == "<class 'list'>":
                        list_of_nums_cand_b[i] = len(self.sudoku_table[cell[0]][cell[1]])
                
                for lu, lm, ln, lo, ld in combinations([i for i in range(9) if 2 <= list_of_nums_cand_b[i] <= 5], 5):
                    cells = [(r, lu), (r, lm), (r, ln), (r, lo), (r, ld)]
                    union = set()
                    for cell in cells:
                        union.update(self.sudoku_table[cell[0]][cell[1]])
                    if len(union) == 5:
                        for i in range(9):
                            cell = (r, i)
                            if cell not in cells and str(type(self.sudoku_table[cell[0]][cell[1]])) == "<class 'list'>":
                                new_values = [x for x in self.sudoku_table[cell[0]][cell[1]] if x not in union]
                                if len(new_values) < len(self.sudoku_table[cell[0]][cell[1]]):
                                    self.sudoku_table[cell[0]][cell[1]] = new_values
                                    self.list_of_changes_solving_mode.append(f"#{self.action} --- Reduced to {new_values} in cell {self.letter_for_collumn(cell[1])}{cell[0]+1} (obvious quint in row #{r+1})")
                                    self.action += 1
                                    table_changed = self.ch_gl = self.moderate = True
                                    self.uses["Naked Quint"] += 1

    def sword_fish_ext(self):
        table_changed = True
        while table_changed and self.solvability == "possible":
            table_changed = False
            for k in range(1, 10):
                num_is_valid_for_method = True
                meet_thrice_in_column_c = []
                num_is_valid_for_method_alt = True
                meet_thrice_in_row_c = []
                if num_is_valid_for_method:
                    for c in range(9):
                        k_times = []
                        for r in range(9):
                            if str(type(self.sudoku_table[r][c]))=="<class 'list'>":
                                if k in self.sudoku_table[r][c]:
                                    k_times.append(r)
                        if len(k_times) == 3:
                            meet_thrice_in_column_c.append([[k_times[0], c], [k_times[1], c], [k_times[2], c]])
                        elif len(k_times) == 2:
                            meet_thrice_in_column_c.append([[k_times[0], c], [k_times[1], c]])
                        elif len(k_times) == 1:
                            num_is_valid_for_method = False
                    if len(meet_thrice_in_column_c) >= 3 and num_is_valid_for_method:
                        allowed_b = False
                        for lu, lm, ld in ((lu, lm, ld) for lu in range(len(meet_thrice_in_column_c)-2) for lm in range(lu + 1, len(meet_thrice_in_column_c)-1) for ld in range(lm + 1, len(meet_thrice_in_column_c))):
                            if len(meet_thrice_in_column_c[lu]) == 3 or len(meet_thrice_in_column_c[lm]) == 3 or len(meet_thrice_in_column_c[ld]) == 3:
                                rows_k = sorted(set([row[0] for row in meet_thrice_in_column_c[lu] if row] + [row[0] for row in meet_thrice_in_column_c[lm] if row] + [row[0] for row in meet_thrice_in_column_c[ld] if row]))
                                columns_k = sorted(set([row[1] for row in meet_thrice_in_column_c[lu] if row] + [row[1] for row in meet_thrice_in_column_c[lm] if row] + [row[1] for row in meet_thrice_in_column_c[ld] if row]))
                                if len(rows_k)==3 and len(columns_k)==3:
                                    if len(sorted(set([a//3 for a in rows_k])))*len(sorted(set([a//3 for a in columns_k]))) >= 4:
                                        allowed_b = True
                                        break
                        if allowed_b:
                            allowed = True
                            for u in list(set(list(range(len(meet_thrice_in_column_c)))) - set([lu, lm, ld])):
                                if list(set([row[0] for row in meet_thrice_in_column_c[u] if row]) - set(rows_k)) == 0:
                                    allowed = False
                                    break
                            if allowed:
                                for g in range(9):
                                    if str(type(self.sudoku_table[rows_k[0]][g]))=="<class 'list'>" and g not in columns_k:
                                        if k in self.sudoku_table[rows_k[0]][g]:
                                            self.sudoku_table[rows_k[0]][g].remove(int(k))
                                            self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {k} from list of p.n. in cell {self.letter_for_collumn(g)}{rows_k[0]+1} (due to extended swordfishing in rows {rows_k})")
                                            self.action += 1
                                            table_changed, self.ch_gl, self.moderate = True, True, True
                                            self.uses["Swordfishing"] += 1
                                    if str(type(self.sudoku_table[rows_k[1]][g]))=="<class 'list'>" and g not in columns_k:
                                        if k in self.sudoku_table[rows_k[1]][g]:
                                            self.sudoku_table[rows_k[1]][g].remove(int(k))
                                            self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {k} from list of p.n. in cell {self.letter_for_collumn(g)}{rows_k[1]+1} (due to extended swordfishing in rows {rows_k})")
                                            self.action += 1
                                            table_changed, self.ch_gl, self.moderate = True, True, True
                                            self.uses["Swordfishing"] += 1
                                    if str(type(self.sudoku_table[rows_k[2]][g]))=="<class 'list'>" and g not in columns_k:
                                        if k in self.sudoku_table[rows_k[2]][g]:
                                            self.sudoku_table[rows_k[2]][g].remove(int(k))
                                            self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {k} from list of p.n. in cell {self.letter_for_collumn(g)}{rows_k[2]+1} (due to extended swordfishing in rows {rows_k})")
                                            self.action += 1
                                            table_changed, self.ch_gl, self.moderate = True, True, True
                                            self.uses["Swordfishing"] += 1
                if num_is_valid_for_method_alt:
                    for r in range(9):
                        k_times = []
                        for c in range(9):
                            if str(type(self.sudoku_table[r][c]))=="<class 'list'>":
                                if k in self.sudoku_table[r][c]:
                                    k_times.append(c)
                        if len(k_times) == 3:
                            meet_thrice_in_row_c.append([[r, k_times[0]], [r, k_times[1]], [r, k_times[2]]])
                        elif len(k_times) == 2:
                            meet_thrice_in_row_c.append([[r, k_times[0]], [r, k_times[1], c]])
                        elif len(k_times) == 1:
                            num_is_valid_for_method_alt = False
                    if len(meet_thrice_in_row_c) >= 3 and num_is_valid_for_method_alt:
                        allowed_b = False
                        for lu, lm, ld in ((lu, lm, ld) for lu in range(len(meet_thrice_in_row_c)-2) for lm in range(lu + 1, len(meet_thrice_in_row_c)-1) for ld in range(lm + 1, len(meet_thrice_in_row_c))):
                            if len(meet_thrice_in_row_c[lu]) == 3 or len(meet_thrice_in_row_c[lm]) == 3 or len(meet_thrice_in_row_c[ld]) == 3:
                                rows_k = sorted(set([row[0] for row in meet_thrice_in_row_c[lu] if row] + [row[0] for row in meet_thrice_in_row_c[lm] if row] + [row[0] for row in meet_thrice_in_row_c[ld] if row]))
                                columns_k = sorted(set([row[1] for row in meet_thrice_in_row_c[lu] if row] + [row[1] for row in meet_thrice_in_row_c[lm] if row] + [row[1] for row in meet_thrice_in_row_c[ld] if row]))
                                if len(rows_k)==3 and len(columns_k)==3:
                                    if len(sorted(set([a//3 for a in rows_k])))*len(sorted(set([a//3 for a in columns_k]))) >= 4:
                                        allowed_b = True
                                        break
                        if allowed_b:
                            allowed = True
                            for u in list(set(list(range(len(meet_thrice_in_row_c)))) - set([lu, lm, ld])):
                                if list(set([row[1] for row in meet_thrice_in_row_c[u] if row]) - set(columns_k)) == 0:
                                    allowed = False
                                    break
                            if allowed:
                                for g in range(9):
                                    if str(type(self.sudoku_table[g][columns_k[0]]))=="<class 'list'>" and g not in rows_k:
                                        if k in self.sudoku_table[g][columns_k[0]]:
                                            self.sudoku_table[g][columns_k[0]].remove(int(k))
                                            self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {k} from list of p.n. in cell {self.letter_for_collumn(columns_k[0])}{g+1} (due to extended swordfishing in columns {columns_k})")
                                            self.action += 1
                                            table_changed, self.ch_gl, self.moderate = True, True, True
                                            self.uses["Swordfishing"] += 1
                                    if str(type(self.sudoku_table[g][columns_k[1]]))=="<class 'list'>" and g not in rows_k:
                                        if k in self.sudoku_table[g][columns_k[1]]:
                                            self.sudoku_table[g][columns_k[1]].remove(int(k))
                                            self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {k} from list of p.n. in cell {self.letter_for_collumn(columns_k[1])}{g+1} (due to extended swordfishing in columns {columns_k})")
                                            self.action += 1
                                            table_changed, self.ch_gl, self.moderate = True, True, True
                                            self.uses["Swordfishing"] += 1
                                    if str(type(self.sudoku_table[g][columns_k[2]]))=="<class 'list'>" and g not in rows_k:
                                        if k in self.sudoku_table[g][columns_k[2]]:
                                            self.sudoku_table[g][columns_k[2]].remove(int(k))
                                            self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {k} from list of p.n. in cell {self.letter_for_collumn(columns_k[2])}{g+1} (due to extended swordfishing in columns {columns_k})")
                                            self.action += 1
                                            table_changed, self.ch_gl, self.moderate = True, True, True
                                            self.uses["Swordfishing"] += 1

    def jellyfish(self):
        table_changed = True
        while table_changed and self.solvability == "possible":
            table_changed = False
            for k in range(1, 10):
                num_is_valid_for_method = True
                meet_four_t_in_column_c = []
                num_is_valid_for_method_alt = True
                meet_four_t_in_row_c = []
                if num_is_valid_for_method:
                    for c in range(9):
                        k_times = []
                        for r in range(9):
                            if str(type(self.sudoku_table[r][c]))=="<class 'list'>":
                                if k in self.sudoku_table[r][c]:
                                    k_times.append(r)
                        if len(k_times) == 4:
                            meet_four_t_in_column_c.append([[k_times[0], c], [k_times[1], c], [k_times[2], c], [k_times[3], c]])
                        elif len(k_times) == 3:
                            meet_four_t_in_column_c.append([[k_times[0], c], [k_times[1], c], [k_times[2], c]])
                        elif len(k_times) == 2:
                            meet_four_t_in_column_c.append([[k_times[0], c], [k_times[1], c]])
                        elif len(k_times) == 1:
                            num_is_valid_for_method = False
                    if len(meet_four_t_in_column_c) >= 4 and num_is_valid_for_method:
                        allowed_b = False
                        for lu, lm, ln, ld in ((lu, lm, ln, ld) for lu in range(len(meet_four_t_in_column_c)-3) for lm in range(lu + 1, len(meet_four_t_in_column_c)-2) for ln in range(lm + 1, len(meet_four_t_in_column_c)-1) for ld in range(ln + 1, len(meet_four_t_in_column_c))):
                            rows_k = sorted(set([row[0] for row in meet_four_t_in_column_c[lu] if row] + [row[0] for row in meet_four_t_in_column_c[lm] if row] + [row[0] for row in meet_four_t_in_column_c[ln] if row] + [row[0] for row in meet_four_t_in_column_c[ld] if row]))
                            columns_k = sorted(set([row[1] for row in meet_four_t_in_column_c[lu] if row] + [row[1] for row in meet_four_t_in_column_c[lm] if row] + [row[1] for row in meet_four_t_in_column_c[ln] if row] + [row[1] for row in meet_four_t_in_column_c[ld] if row]))
                            if len(rows_k)==4 and len(columns_k)==4:
                                if sum(1 for a in [a//3 for a in rows_k] if a == 0) < 3 and sum(1 for a in [a//3 for a in rows_k] if a == 1) < 3 and sum(1 for a in [a//3 for a in rows_k] if a == 2) < 3 and sum(1 for a in [a//3 for a in columns_k] if a == 0) < 3 and sum(1 for a in [a//3 for a in columns_k] if a == 1) < 3 and sum(1 for a in [a//3 for a in columns_k] if a == 2) < 3:
                                    allowed_b = True
                                    break
                        if allowed_b:
                            allowed = True
                            for u in list(set(list(range(len(meet_four_t_in_column_c)))) - set([lu, lm, ln, ld])):
                                if list(set([row[0] for row in meet_four_t_in_column_c[u] if row]) - set(rows_k)) == 0:
                                    allowed = False
                                    break
                            if allowed:
                                for g in range(9):
                                    if str(type(self.sudoku_table[rows_k[0]][g]))=="<class 'list'>" and g not in columns_k:
                                        if k in self.sudoku_table[rows_k[0]][g]:
                                            self.sudoku_table[rows_k[0]][g].remove(int(k))
                                            self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {k} from list of p.n. in cell {self.letter_for_collumn(g)}{rows_k[0]+1} (due to extended jellyfishing in rows)")
                                            self.action += 1
                                            table_changed, self.ch_gl, self.moderate = True, True, True
                                            self.uses["Jellyfishing"] += 1
                                    if str(type(self.sudoku_table[rows_k[1]][g]))=="<class 'list'>" and g not in columns_k:
                                        if k in self.sudoku_table[rows_k[1]][g]:
                                            self.sudoku_table[rows_k[1]][g].remove(int(k))
                                            self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {k} from list of p.n. in cell {self.letter_for_collumn(g)}{rows_k[1]+1} (due to extended jellyfishing in rows)")
                                            self.action += 1
                                            table_changed, self.ch_gl, self.moderate = True, True, True
                                            self.uses["Jellyfishing"] += 1
                                    if str(type(self.sudoku_table[rows_k[2]][g]))=="<class 'list'>" and g not in columns_k:
                                        if k in self.sudoku_table[rows_k[2]][g]:
                                            self.sudoku_table[rows_k[2]][g].remove(int(k))
                                            self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {k} from list of p.n. in cell {self.letter_for_collumn(g)}{rows_k[2]+1} (due to extended jellyfishing in rows)")
                                            self.action += 1
                                            table_changed, self.ch_gl, self.moderate = True, True, True
                                            self.uses["Jellyfishing"] += 1
                                    if str(type(self.sudoku_table[rows_k[3]][g]))=="<class 'list'>" and g not in columns_k:
                                        if k in self.sudoku_table[rows_k[3]][g]:
                                            self.sudoku_table[rows_k[3]][g].remove(int(k))
                                            self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {k} from list of p.n. in cell {self.letter_for_collumn(g)}{rows_k[3]+1} (due to extended jellyfishing in rows)")
                                            self.action += 1
                                            table_changed, self.ch_gl, self.moderate = True, True, True
                                            self.uses["Jellyfishing"] += 1
                if num_is_valid_for_method_alt:
                    for r in range(9):
                        k_times = []
                        for c in range(9):
                            if str(type(self.sudoku_table[r][c]))=="<class 'list'>":
                                if k in self.sudoku_table[r][c]:
                                    k_times.append(c)
                        if len(k_times) == 4:
                            meet_four_t_in_row_c.append([[r, k_times[0]], [r, k_times[1]], [r, k_times[2]], [r, k_times[3]]])
                        elif len(k_times) == 3:
                            meet_four_t_in_row_c.append([[r, k_times[0]], [r, k_times[1]], [r, k_times[2]]])
                        elif len(k_times) == 2:
                            meet_four_t_in_row_c.append([[r, k_times[0]], [r, k_times[1], c]])
                        elif len(k_times) == 1:
                            num_is_valid_for_method_alt = False
                    if len(meet_four_t_in_row_c) >= 4 and num_is_valid_for_method_alt:
                        allowed_b = False
                        for lu, lm, ln, ld in ((lu, lm, ln, ld) for lu in range(len(meet_four_t_in_row_c)-3) for lm in range(lu + 1, len(meet_four_t_in_row_c)-2) for ln in range(lm + 1, len(meet_four_t_in_row_c)-1) for ld in range(ln + 1, len(meet_four_t_in_row_c))):
                            rows_k = sorted(set([row[0] for row in meet_four_t_in_row_c[lu] if row] + [row[0] for row in meet_four_t_in_row_c[lm] if row] + [row[0] for row in meet_four_t_in_row_c[ln] if row] + [row[0] for row in meet_four_t_in_row_c[ld] if row]))
                            columns_k = sorted(set([row[1] for row in meet_four_t_in_row_c[lu] if row] + [row[1] for row in meet_four_t_in_row_c[lm] if row] + [row[1] for row in meet_four_t_in_row_c[ln] if row] + [row[1] for row in meet_four_t_in_row_c[ld] if row]))
                            if len(rows_k)==4 and len(columns_k)==4:
                                if sum(1 for a in [a//3 for a in rows_k] if a == 0) < 3 and sum(1 for a in [a//3 for a in rows_k] if a == 1) < 3 and sum(1 for a in [a//3 for a in rows_k] if a == 2) < 3 and sum(1 for a in [a//3 for a in columns_k] if a == 0) < 3 and sum(1 for a in [a//3 for a in columns_k] if a == 1) < 3 and sum(1 for a in [a//3 for a in columns_k] if a == 2) < 3:
                                    allowed_b = True
                                    break
                        if allowed_b:
                            allowed = True
                            for u in list(set(list(range(len(meet_four_t_in_row_c)))) - set([lu, lm, ln, ld])):
                                if list(set([row[1] for row in meet_four_t_in_row_c[u] if row]) - set(columns_k)) == 0:
                                    allowed = False
                                    break
                            if allowed:
                                for g in range(9):
                                    if str(type(self.sudoku_table[g][columns_k[0]]))=="<class 'list'>" and g not in rows_k:
                                        if k in self.sudoku_table[g][columns_k[0]]:
                                            self.sudoku_table[g][columns_k[0]].remove(int(k))
                                            self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {k} from list of p.n. in cell {self.letter_for_collumn(columns_k[0])}{g+1} (due to extended jellyfishing in columns)")
                                            self.action += 1
                                            table_changed, self.ch_gl, self.moderate = True, True, True
                                            self.uses["Jellyfishing"] += 1
                                    if str(type(self.sudoku_table[g][columns_k[1]]))=="<class 'list'>" and g not in rows_k:
                                        if k in self.sudoku_table[g][columns_k[1]]:
                                            self.sudoku_table[g][columns_k[1]].remove(int(k))
                                            self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {k} from list of p.n. in cell {self.letter_for_collumn(columns_k[1])}{g+1} (due to extended jellyfishing in columns)")
                                            self.action += 1
                                            table_changed, self.ch_gl, self.moderate = True, True, True
                                            self.uses["Jellyfishing"] += 1
                                    if str(type(self.sudoku_table[g][columns_k[2]]))=="<class 'list'>" and g not in rows_k:
                                        if k in self.sudoku_table[g][columns_k[2]]:
                                            self.sudoku_table[g][columns_k[2]].remove(int(k))
                                            self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {k} from list of p.n. in cell {self.letter_for_collumn(columns_k[2])}{g+1} (due to extended jellyfishing in columns)")
                                            self.action += 1
                                            table_changed, self.ch_gl, self.moderate = True, True, True
                                            self.uses["Jellyfishing"] += 1
                                    if str(type(self.sudoku_table[g][columns_k[3]]))=="<class 'list'>" and g not in rows_k:
                                        if k in self.sudoku_table[g][columns_k[3]]:
                                            self.sudoku_table[g][columns_k[3]].remove(int(k))
                                            self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {k} from list of p.n. in cell {self.letter_for_collumn(columns_k[3])}{g+1} (due to extended jellyfishing in columns)")
                                            self.action += 1
                                            table_changed, self.ch_gl, self.moderate = True, True, True
                                            self.uses["Jellyfishing"] += 1

    def starfish(self): 
        table_changed = True
        while table_changed and self.solvability == "possible":
            table_changed = False
            for k in range(1, 10):
                num_is_valid_for_method = True
                meet_four_t_in_column_c = []
                num_is_valid_for_method_alt = True
                meet_four_t_in_row_c = []
                if num_is_valid_for_method:
                    for c in range(9):
                        k_times = []
                        for r in range(9):
                            if str(type(self.sudoku_table[r][c]))=="<class 'list'>":
                                if k in self.sudoku_table[r][c]:
                                    k_times.append(r)
                        if len(k_times) == 5:
                            meet_four_t_in_column_c.append([[k_times[0], c], [k_times[1], c], [k_times[2], c], [k_times[3], c], [k_times[4], c]])
                        elif len(k_times) == 4:
                            meet_four_t_in_column_c.append([[k_times[0], c], [k_times[1], c], [k_times[2], c], [k_times[3], c]])
                        elif len(k_times) == 3:
                            meet_four_t_in_column_c.append([[k_times[0], c], [k_times[1], c], [k_times[2], c]])
                        elif len(k_times) == 2:
                            meet_four_t_in_column_c.append([[k_times[0], c], [k_times[1], c]])
                        elif len(k_times) == 1:
                            num_is_valid_for_method = False
                    if len(meet_four_t_in_column_c) >= 5 and num_is_valid_for_method:
                        allowed_b = False
                        for lu, lm, ln, lo, ld in ((lu, lm, ln, lo, ld) for lu in range(len(meet_four_t_in_column_c)-4) for lm in range(lu + 1, len(meet_four_t_in_column_c)-3) for ln in range(lm + 1, len(meet_four_t_in_column_c)-2) for lo in range(ln + 1, len(meet_four_t_in_column_c)-1) for ld in range(lo + 1, len(meet_four_t_in_column_c))):
                            rows_k = sorted(set([row[0] for row in meet_four_t_in_column_c[lu] if row] + [row[0] for row in meet_four_t_in_column_c[lm] if row] + [row[0] for row in meet_four_t_in_column_c[ln] if row] + [row[0] for row in meet_four_t_in_column_c[lo] if row] + [row[0] for row in meet_four_t_in_column_c[ld] if row]))
                            columns_k = sorted(set([row[1] for row in meet_four_t_in_column_c[lu] if row] + [row[1] for row in meet_four_t_in_column_c[lm] if row] + [row[1] for row in meet_four_t_in_column_c[ln] if row] + [row[1] for row in meet_four_t_in_column_c[lo] if row] + [row[1] for row in meet_four_t_in_column_c[ld] if row]))
                            if len(rows_k)==5 and len(columns_k)==5:
                                if ((sum(1 for a in [a//3 for a in rows_k] if a == 0) == 3 or sum(1 for a in [a//3 for a in rows_k] if a == 1) == 3 or sum(1 for a in [a//3 for a in rows_k] if a == 2) == 3) and sum(1 for a in [a//3 for a in columns_k] if a == 0) < 3 and sum(1 for a in [a//3 for a in columns_k] if a == 1) < 3 and sum(1 for a in [a//3 for a in columns_k] if a == 2) < 3) or ((sum(1 for a in [a//3 for a in columns_k] if a == 0) == 3 or sum(1 for a in [a//3 for a in columns_k] if a == 1) == 3 or sum(1 for a in [a//3 for a in columns_k] if a == 2) == 3) and sum(1 for a in [a//3 for a in rows_k] if a == 0) < 3 and sum(1 for a in [a//3 for a in rows_k] if a == 1) < 3 and sum(1 for a in [a//3 for a in rows_k] if a == 2) < 3):
                                    allowed_b = True
                                    break
                        if allowed_b:
                            allowed = True
                            for u in list(set(list(range(len(meet_four_t_in_column_c)))) - set([lu, lm, ln, lo, ld])):
                                if list(set([row[0] for row in meet_four_t_in_column_c[u] if row]) - set(rows_k)) == 0:
                                    allowed = False
                                    break
                            if allowed:
                                for g in range(9):
                                    if str(type(self.sudoku_table[rows_k[0]][g]))=="<class 'list'>" and g not in columns_k:
                                        if k in self.sudoku_table[rows_k[0]][g]:
                                            self.sudoku_table[rows_k[0]][g].remove(int(k))
                                            self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {k} from list of p.n. in cell {self.letter_for_collumn(g)}{rows_k[0]+1} (due to starfishing in rows)")
                                            self.action += 1
                                            table_changed, self.ch_gl, self.moderate = True, True, True
                                            self.uses["Starfishing"] += 1
                                    if str(type(self.sudoku_table[rows_k[1]][g]))=="<class 'list'>" and g not in columns_k:
                                        if k in self.sudoku_table[rows_k[1]][g]:
                                            self.sudoku_table[rows_k[1]][g].remove(int(k))
                                            self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {k} from list of p.n. in cell {self.letter_for_collumn(g)}{rows_k[1]+1} (due to starfishing in rows)")
                                            self.action += 1
                                            table_changed, self.ch_gl, self.moderate = True, True, True
                                            self.uses["Starfishing"] += 1
                                    if str(type(self.sudoku_table[rows_k[2]][g]))=="<class 'list'>" and g not in columns_k:
                                        if k in self.sudoku_table[rows_k[2]][g]:
                                            self.sudoku_table[rows_k[2]][g].remove(int(k))
                                            self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {k} from list of p.n. in cell {self.letter_for_collumn(g)}{rows_k[2]+1} (due to starfishing in rows)")
                                            self.action += 1
                                            table_changed, self.ch_gl, self.moderate = True, True, True
                                            self.uses["Starfishing"] += 1
                                    if str(type(self.sudoku_table[rows_k[3]][g]))=="<class 'list'>" and g not in columns_k:
                                        if k in self.sudoku_table[rows_k[3]][g]:
                                            self.sudoku_table[rows_k[3]][g].remove(int(k))
                                            self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {k} from list of p.n. in cell {self.letter_for_collumn(g)}{rows_k[3]+1} (due to starfishing in rows)")
                                            self.action += 1
                                            table_changed, self.ch_gl, self.moderate = True, True, True
                                            self.uses["Starfishing"] += 1
                                    if str(type(self.sudoku_table[rows_k[4]][g]))=="<class 'list'>" and g not in columns_k:
                                        if k in self.sudoku_table[rows_k[4]][g]:
                                            self.sudoku_table[rows_k[4]][g].remove(int(k))
                                            self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {k} from list of p.n. in cell {self.letter_for_collumn(g)}{rows_k[4]+1} (due to starfishing in rows)")
                                            self.action += 1
                                            table_changed, self.ch_gl, self.moderate = True, True, True
                                            self.uses["Starfishing"] += 1
                if num_is_valid_for_method_alt:
                    for r in range(9):
                        k_times = []
                        for c in range(9):
                            if str(type(self.sudoku_table[r][c]))=="<class 'list'>":
                                if k in self.sudoku_table[r][c]:
                                    k_times.append(c)
                        if len(k_times) == 5:
                            meet_four_t_in_row_c.append([[r, k_times[0]], [r, k_times[1]], [r, k_times[2]], [r, k_times[3]], [r, k_times[3]]])
                        elif len(k_times) == 4:
                            meet_four_t_in_row_c.append([[r, k_times[0]], [r, k_times[1]], [r, k_times[2]], [r, k_times[3]]])
                        elif len(k_times) == 3:
                            meet_four_t_in_row_c.append([[r, k_times[0]], [r, k_times[1]], [r, k_times[2]]])
                        elif len(k_times) == 2:
                            meet_four_t_in_row_c.append([[r, k_times[0]], [r, k_times[1], c]])
                        elif len(k_times) == 1:
                            num_is_valid_for_method_alt = False
                    if len(meet_four_t_in_row_c) >= 5 and num_is_valid_for_method_alt:
                        allowed_b = False
                        for lu, lm, ln, lo, ld in ((lu, lm, ln, lo, ld) for lu in range(len(meet_four_t_in_row_c)-4) for lm in range(lu + 1, len(meet_four_t_in_row_c)-3) for ln in range(lm + 1, len(meet_four_t_in_row_c)-2) for lo in range(ln + 1, len(meet_four_t_in_row_c)-1) for ld in range(lo + 1, len(meet_four_t_in_row_c))):
                            rows_k = sorted(set([row[0] for row in meet_four_t_in_row_c[lu] if row] + [row[0] for row in meet_four_t_in_row_c[lm] if row] + [row[0] for row in meet_four_t_in_row_c[ln] if row] + [row[0] for row in meet_four_t_in_row_c[lo] if row] + [row[0] for row in meet_four_t_in_row_c[ld] if row]))
                            columns_k = sorted(set([row[1] for row in meet_four_t_in_row_c[lu] if row] + [row[1] for row in meet_four_t_in_row_c[lm] if row] + [row[1] for row in meet_four_t_in_row_c[ln] if row] + [row[1] for row in meet_four_t_in_row_c[lo] if row] + [row[1] for row in meet_four_t_in_row_c[ld] if row]))
                            if len(rows_k)==5 and len(columns_k)==5:
                                if ((sum(1 for a in [a//3 for a in rows_k] if a == 0) == 3 or sum(1 for a in [a//3 for a in rows_k] if a == 1) == 3 or sum(1 for a in [a//3 for a in rows_k] if a == 2) == 3) and sum(1 for a in [a//3 for a in columns_k] if a == 0) < 3 and sum(1 for a in [a//3 for a in columns_k] if a == 1) < 3 and sum(1 for a in [a//3 for a in columns_k] if a == 2) < 3) or ((sum(1 for a in [a//3 for a in columns_k] if a == 0) == 3 or sum(1 for a in [a//3 for a in columns_k] if a == 1) == 3 or sum(1 for a in [a//3 for a in columns_k] if a == 2) == 3) and sum(1 for a in [a//3 for a in rows_k] if a == 0) < 3 and sum(1 for a in [a//3 for a in rows_k] if a == 1) < 3 and sum(1 for a in [a//3 for a in rows_k] if a == 2) < 3):
                                    allowed_b = True
                                    break
                        if allowed_b:
                            allowed = True
                            for u in list(set(list(range(len(meet_four_t_in_row_c)))) - set([lu, lm, ln, lo, ld])):
                                if list(set([row[1] for row in meet_four_t_in_row_c[u] if row]) - set(columns_k)) == 0:
                                    allowed = False
                                    break
                            if allowed:
                                for g in range(9):
                                    if str(type(self.sudoku_table[g][columns_k[0]]))=="<class 'list'>" and g not in rows_k:
                                        if k in self.sudoku_table[g][columns_k[0]]:
                                            self.sudoku_table[g][columns_k[0]].remove(int(k))
                                            self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {k} from list of p.n. in cell {self.letter_for_collumn(columns_k[0])}{g+1} (due to starfishing in columns)")
                                            self.action += 1
                                            table_changed, self.ch_gl, self.moderate = True, True, True
                                            self.uses["Starfishing"] += 1
                                    if str(type(self.sudoku_table[g][columns_k[1]]))=="<class 'list'>" and g not in rows_k:
                                        if k in self.sudoku_table[g][columns_k[1]]:
                                            self.sudoku_table[g][columns_k[1]].remove(int(k))
                                            self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {k} from list of p.n. in cell {self.letter_for_collumn(columns_k[1])}{g+1} (due to starfishing in columns)")
                                            self.action += 1
                                            table_changed, self.ch_gl, self.moderate = True, True, True
                                            self.uses["Starfishing"] += 1
                                    if str(type(self.sudoku_table[g][columns_k[2]]))=="<class 'list'>" and g not in rows_k:
                                        if k in self.sudoku_table[g][columns_k[2]]:
                                            self.sudoku_table[g][columns_k[2]].remove(int(k))
                                            self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {k} from list of p.n. in cell {self.letter_for_collumn(columns_k[2])}{g+1} (due to starfishing in columns)")
                                            self.action += 1
                                            table_changed, self.ch_gl, self.moderate = True, True, True
                                            self.uses["Starfishing"] += 1
                                    if str(type(self.sudoku_table[g][columns_k[3]]))=="<class 'list'>" and g not in rows_k:
                                        if k in self.sudoku_table[g][columns_k[3]]:
                                            self.sudoku_table[g][columns_k[3]].remove(int(k))
                                            self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {k} from list of p.n. in cell {self.letter_for_collumn(columns_k[3])}{g+1} (due to starfishing in columns)")
                                            self.action += 1
                                            table_changed, self.ch_gl, self.moderate = True, True, True
                                            self.uses["Starfishing"] += 1
                                    if str(type(self.sudoku_table[g][columns_k[4]]))=="<class 'list'>" and g not in rows_k:
                                        if k in self.sudoku_table[g][columns_k[4]]:
                                            self.sudoku_table[g][columns_k[4]].remove(int(k))
                                            self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {k} from list of p.n. in cell {self.letter_for_collumn(columns_k[4])}{g+1} (due to starfishing in columns)")
                                            self.action += 1
                                            table_changed, self.ch_gl, self.moderate = True, True, True
                                            self.uses["Starfishing"] += 1

    def skyscraper(self):
        table_changed = True
        while table_changed and self.solvability == "possible":
            table_changed = False
            for k in range(1, 10):
                num_is_valid_for_method = True
                meet_twice_in_column_c = []
                num_is_valid_for_method_alt = True
                meet_twice_in_row_c = []
                if num_is_valid_for_method:
                    for c in range(9):
                        k_times = []
                        for r in range(9):
                            if str(type(self.sudoku_table[r][c]))=="<class 'list'>":
                                if k in self.sudoku_table[r][c]:
                                    k_times.append(r)
    def x_wing(self):
        table_changed = True
        while table_changed and self.solvability == "possible":
            table_changed = False
            for k in range(1, 10):
                num_is_valid_for_method = True
                meet_twice_in_column_c = []
                num_is_valid_for_method_alt = True
                meet_twice_in_row_c = []
                if num_is_valid_for_method:
                    for c in range(9):
                        k_times = []
                        for r in range(9):
                            if str(type(self.sudoku_table[r][c]))=="<class 'list'>":
                                if k in self.sudoku_table[r][c]:
                                    k_times.append(r)
                        if len(k_times) == 2:
                            meet_twice_in_column_c.append([[k_times[0], c], [k_times[1], c]])
                        elif len(k_times) == 1:
                            num_is_valid_for_method = False
                    meet_twice_in_column_k = update_up_for_x_winging(meet_twice_in_column_c, 1)
                if len(meet_twice_in_column_c) == 2:
                    if meet_twice_in_column_c[0][0][1]//3 != meet_twice_in_column_c[1][0][1]//3 and meet_twice_in_column_c[0][0][0]//3 != meet_twice_in_column_c[0][1][0]//3 and meet_twice_in_column_c[1][0][0]//3 != meet_twice_in_column_c[1][1][0]//3:
                        if meet_twice_in_column_c[0][0][0] == meet_twice_in_column_c[1][0][0] and meet_twice_in_column_c[0][1][0] != meet_twice_in_column_c[1][1][0] and meet_twice_in_column_c[0][1][0]//3 == meet_twice_in_column_c[1][1][0]//3:
                            for f in [x for x in range(9) if x // 3 == meet_twice_in_column_c[0][0][1]//3]:
                                if str(type(self.sudoku_table[meet_twice_in_column_c[1][1][0]][f]))=="<class 'list'>":
                                    if k in self.sudoku_table[meet_twice_in_column_c[1][1][0]][f]:
                                        self.sudoku_table[meet_twice_in_column_c[1][1][0]][f].remove(int(k))
                                        self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {k} from list of p.n. in cell {self.letter_for_collumn_c(f)}{meet_twice_in_column[1][1][0]+1} (due to x-winging)")
                                        self.action += 1
                                        table_changed, self.ch_gl, self.moderate = True, True, True
                                        self.uses["Skyscrapering"] += 1
                            for g in [x for x in range(9) if x // 3 == meet_twice_in_column_c[1][0][1]//3]:
                                if str(type(self.sudoku_table[meet_twice_in_column_c[0][1][0]][g]))=="<class 'list'>":
                                    if k in self.sudoku_table[meet_twice_in_column_c[0][1][0]][g]:
                                        self.sudoku_table[meet_twice_in_column_c[0][1][0]][g].remove(int(k))
                                        self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {k} from list of p.n. in cell {self.letter_for_collumn_c(g)}{meet_twice_in_column[0][1][0]+1} (due to x-winging)")
                                        self.action += 1
                                        table_changed, self.ch_gl, self.moderate = True, True, True
                                        self.uses["Skyscrapering"] += 1
                        elif meet_twice_in_column_c[0][0][0] != meet_twice_in_column_c[1][0][0] and meet_twice_in_column_c[0][1][0] == meet_twice_in_column_c[1][1][0] and meet_twice_in_column_c[0][0][0]//3 == meet_twice_in_column_c[1][0][0]//3:
                            for f in [x for x in range(9) if x // 3 == meet_twice_in_column_c[0][0][1]//3]:
                                if str(type(self.sudoku_table[meet_twice_in_column_c[1][0][0]][f]))=="<class 'list'>":
                                    if k in self.sudoku_table[meet_twice_in_column_c[1][0][0]][f]:
                                        self.sudoku_table[meet_twice_in_column_c[1][0][0]][f].remove(int(k))
                                        self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {k} from list of p.n. in cell {self.letter_for_collumn_c(f)}{meet_twice_in_column[1][0][0]+1} (due to x-winging)")
                                        self.action += 1
                                        table_changed, self.ch_gl, self.moderate = True, True, True
                                        self.uses["Skyscrapering"] += 1
                            for g in [x for x in range(9) if x // 3 == meet_twice_in_column_c[1][0][1]//3]:
                                if str(type(self.sudoku_table[meet_twice_in_column_c[0][0][0]][g]))=="<class 'list'>":
                                    if k in self.sudoku_table[meet_twice_in_column_c[0][0][0]][g]:
                                        self.sudoku_table[meet_twice_in_column_c[0][0][0]][g].remove(int(k))
                                        self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {k} from list of p.n. in cell {self.letter_for_collumn_c(g)}{meet_twice_in_column[0][0][0]+1} (due to x-winging)")
                                        self.action += 1
                                        table_changed, self.ch_gl, self.moderate = True, True, True
                                        self.uses["Skyscrapering"] += 1    
                for meet_twice_in_column in meet_twice_in_column_k:
                    if num_is_valid_for_method and len(meet_twice_in_column) == 2:
                        if meet_twice_in_column[0][0][0] == meet_twice_in_column[1][0][0] and meet_twice_in_column[0][1][0] == meet_twice_in_column[1][1][0]:
                            if not self.check_if_in_the_same_block(meet_twice_in_column[0][0], meet_twice_in_column[0][1], meet_twice_in_column[1][0], meet_twice_in_column[1][1]):
                                for g in range(9):
                                    if str(type(self.sudoku_table[meet_twice_in_column[0][0][0]][g]))=="<class 'list'>" and g not in [meet_twice_in_column[0][0][1], meet_twice_in_column[1][0][1]]:
                                        if k in self.sudoku_table[meet_twice_in_column[0][0][0]][g]:
                                            self.sudoku_table[meet_twice_in_column[0][0][0]][g].remove(int(k))
                                            self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {k} from list of p.n. in cell {self.letter_for_collumn(g)}{meet_twice_in_column[0][0][0]+1} (due to x-winging)")
                                            self.action += 1
                                            table_changed, self.ch_gl, self.moderate = True, True, True
                                            self.uses["X-wings"] += 1
                                    if str(type(self.sudoku_table[meet_twice_in_column[0][1][0]][g]))=="<class 'list'>" and g not in [meet_twice_in_column[0][1][1], meet_twice_in_column[1][1][1]]:
                                        if k in self.sudoku_table[meet_twice_in_column[0][1][0]][g]:
                                            self.sudoku_table[meet_twice_in_column[0][1][0]][g].remove(int(k))
                                            self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {k} from list of p.n. in cell {self.letter_for_collumn(g)}{meet_twice_in_column[0][1][0]+1} (due to x-winging)")
                                            self.action += 1
                                            table_changed, self.ch_gl, self.moderate = True, True, True
                                            self.uses["X-wings"] += 1
                    elif num_is_valid_for_method and len(meet_twice_in_column) == 3:
                        if are_sync_ext(meet_twice_in_column[0][0], meet_twice_in_column[0][1], meet_twice_in_column[1][0], meet_twice_in_column[1][1], meet_twice_in_column[2][0], meet_twice_in_column[2][1], 0):
                            extr_rows = []
                            extr_columns = []
                            for cell in [meet_twice_in_column[0][0], meet_twice_in_column[0][1], meet_twice_in_column[1][0], meet_twice_in_column[1][1], meet_twice_in_column[2][0], meet_twice_in_column[2][1]]:
                                if cell[0] not in extr_rows:
                                    extr_rows.append(cell[0])
                                if cell[1] not in extr_columns:
                                    extr_columns.append(cell[1])
                            try:
                                extr_rows = sorted(extr_rows)
                                extr_columns = sorted(extr_columns)
                            except:
                                pass
                            if not self.check_if_in_the_same_block_ext(extr_rows, extr_columns):
                                for g in range(9):
                                    if str(type(self.sudoku_table[extr_rows[0]][g]))=="<class 'list'>" and g not in [extr_columns[0], extr_columns[1], extr_columns[2]]:
                                        if k in self.sudoku_table[extr_rows[0]][g]:
                                            self.sudoku_table[extr_rows[0]][g].remove(int(k))
                                            self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {k} from list of p.n. in cell {self.letter_for_collumn(g)}{extr_rows[0]+1} (due to swordfishing in rows #{extr_rows[0]+1}, {extr_rows[1]+1} & {extr_rows[2]+1})")
                                            self.action += 1
                                            table_changed, self.ch_gl, self.moderate = True, True, True
                                            self.uses["Swordfishing"] += 1
                                    if str(type(self.sudoku_table[extr_rows[1]][g]))=="<class 'list'>" and g not in [extr_columns[0], extr_columns[1], extr_columns[2]]:
                                        if k in self.sudoku_table[extr_rows[1]][g]:
                                            self.sudoku_table[extr_rows[1]][g].remove(int(k))
                                            self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {k} from list of p.n. in cell {self.letter_for_collumn(g)}{extr_rows[1]+1} (due to swordfishing in rows #{extr_rows[0]+1}, {extr_rows[1]+1} & {extr_rows[2]+1})")
                                            self.action += 1
                                            table_changed, self.ch_gl, self.moderate = True, True, True
                                            self.uses["Swordfishing"] += 1
                                    if str(type(self.sudoku_table[extr_rows[2]][g]))=="<class 'list'>" and g not in [extr_columns[0], extr_columns[1], extr_columns[2]]:
                                        if k in self.sudoku_table[extr_rows[2]][g]:
                                            self.sudoku_table[extr_rows[2]][g].remove(int(k))
                                            self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {k} from list of p.n. in cell {self.letter_for_collumn(g)}{extr_rows[2]+1} (due to swordfishing in rows #{extr_rows[0]+1}, {extr_rows[1]+1} & {extr_rows[2]+1})")
                                            self.action += 1
                                            table_changed, self.ch_gl, self.moderate = True, True, True
                                            self.uses["Swordfishing"] += 1
                if num_is_valid_for_method_alt:
                    for r in range(9):
                        k_times = []
                        for c in range(9):
                            if str(type(self.sudoku_table[r][c]))=="<class 'list'>":
                                if k in self.sudoku_table[r][c]:
                                    k_times.append(c)
                        if len(k_times) == 2:
                            meet_twice_in_row_c.append([[r, k_times[0]], [r, k_times[1]]])
                        elif len(k_times) == 1:
                            num_is_valid_for_method_alt = False
                    meet_twice_in_row_k = update_up_for_x_winging(meet_twice_in_row_c, 0)
                if len(meet_twice_in_row_c) == 2:
                    if meet_twice_in_row_c[0][0][0]//3 != meet_twice_in_row_c[1][0][0]//3 and meet_twice_in_row_c[0][0][1]//3 != meet_twice_in_row_c[0][1][1]//3 and meet_twice_in_row_c[1][0][1]//3 != meet_twice_in_row_c[1][1][1]//3:
                        if meet_twice_in_row_c[0][0][1] == meet_twice_in_row_c[1][0][1] and meet_twice_in_row_c[0][1][1] != meet_twice_in_row_c[1][1][1] and meet_twice_in_row_c[0][1][1]//3 == meet_twice_in_row_c[1][1][1]//3:
                            for f in [x for x in range(9) if x // 3 == meet_twice_in_row_c[0][0][0]//3]:
                                if str(type(self.sudoku_table[f][meet_twice_in_row_c[1][1][1]]))=="<class 'list'>":
                                    if k in self.sudoku_table[f][meet_twice_in_row_c[1][1][1]]:
                                        self.sudoku_table[f][meet_twice_in_row_c[1][1][1]].remove(int(k))
                                        self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {k} from list of p.n. in cell {self.letter_for_collumn(meet_twice_in_row_c[1][1][1])}{f+1} (due to x-winging)")
                                        self.action += 1
                                        table_changed, self.ch_gl, self.moderate = True, True, True
                                        self.uses["Skyscrapering"] += 1
                            for g in [x for x in range(9) if x // 3 == meet_twice_in_row_c[1][0][0]//3]:
                                if str(type(self.sudoku_table[g][meet_twice_in_row_c[0][1][1]]))=="<class 'list'>":
                                    if k in self.sudoku_table[g][meet_twice_in_row_c[0][1][1]]:
                                        self.sudoku_table[g][meet_twice_in_row_c[0][1][1]].remove(int(k))
                                        self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {k} from list of p.n. in cell {self.letter_for_collumn(meet_twice_in_row_c[0][1][1])}{g+1} (due to x-winging)")
                                        self.action += 1
                                        table_changed, self.ch_gl, self.moderate = True, True, True
                                        self.uses["Skyscrapering"] += 1
                        elif meet_twice_in_row_c[0][0][0] != meet_twice_in_row_c[1][0][0] and meet_twice_in_row_c[0][1][0] == meet_twice_in_row_c[1][1][0] and meet_twice_in_row_c[0][0][0]//3 == meet_twice_in_row_c[1][0][0]//3:
                            for f in [x for x in range(9) if x // 3 == meet_twice_in_row_c[0][0][0]//3]:
                                if str(type(self.sudoku_table[f][meet_twice_in_row_c[1][0][1]]))=="<class 'list'>":
                                    if k in self.sudoku_table[f][meet_twice_in_row_c[1][0][1]]:
                                        self.sudoku_table[f][meet_twice_in_row_c[1][0][1]].remove(int(k))
                                        self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {k} from list of p.n. in cell {self.letter_for_row_c(meet_twice_in_row_c[1][0][1])}{f+1} (due to x-winging)")
                                        self.action += 1
                                        table_changed, self.ch_gl, self.moderate = True, True, True
                                        self.uses["Skyscrapering"] += 1
                            for g in [x for x in range(9) if x // 3 == meet_twice_in_row_c[1][0][0]//3]:
                                if str(type(self.sudoku_table[g][meet_twice_in_row_c[0][0][1]]))=="<class 'list'>":
                                    if k in self.sudoku_table[g][meet_twice_in_row_c[0][0][1]]:
                                        self.sudoku_table[g][meet_twice_in_row_c[0][0][1]].remove(int(k))
                                        self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {k} from list of p.n. in cell {self.letter_for_row_c(meet_twice_in_row_c[0][0][1])}{g+1} (due to x-winging)")
                                        self.action += 1
                                        table_changed, self.ch_gl, self.moderate = True, True, True
                                        self.uses["Skyscrapering"] += 1
                for meet_twice_in_row in meet_twice_in_row_k:
                    if num_is_valid_for_method_alt and len(meet_twice_in_row) == 2:
                        if meet_twice_in_row[0][0][1] == meet_twice_in_row[1][0][1] and meet_twice_in_row[0][1][1] == meet_twice_in_row[1][1][1]:
                            if not self.check_if_in_the_same_block(meet_twice_in_row[0][0], meet_twice_in_row[0][1], meet_twice_in_row[1][0], meet_twice_in_row[1][1]):
                                for g in range(9):
                                    if str(type(self.sudoku_table[g][meet_twice_in_row[0][0][1]]))=="<class 'list'>" and g not in [meet_twice_in_row[0][0][0], meet_twice_in_row[1][0][0]]:
                                        if k in self.sudoku_table[g][meet_twice_in_row[0][0][1]]:
                                            self.sudoku_table[g][meet_twice_in_row[0][0][1]].remove(int(k))
                                            self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {k} from list of p.n. in cell {self.letter_for_collumn(meet_twice_in_row[0][0][1])}{g+1} (due to x-winging)")
                                            self.action += 1
                                            table_changed, self.ch_gl, self.moderate = True, True, True
                                            self.uses["X-wings"] += 1
                                    if str(type(self.sudoku_table[g][meet_twice_in_row[0][1][1]]))=="<class 'list'>" and g not in [meet_twice_in_row[0][1][0], meet_twice_in_row[1][1][0]]:
                                        if k in self.sudoku_table[g][meet_twice_in_row[0][1][1]]:
                                            self.sudoku_table[g][meet_twice_in_row[0][1][1]].remove(int(k))
                                            self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {k} from list of p.n. in cell {self.letter_for_collumn(meet_twice_in_row[0][1][1])}{g+1} (due to x-winging)")
                                            self.action += 1
                                            table_changed, self.ch_gl, self.moderate = True, True, True
                                            self.uses["X-wings"] += 1
                    elif num_is_valid_for_method_alt and len(meet_twice_in_row) == 3:
                        if are_sync_ext(meet_twice_in_row[0][0], meet_twice_in_row[0][1], meet_twice_in_row[1][0], meet_twice_in_row[1][1], meet_twice_in_row[2][0], meet_twice_in_row[2][1], 1):
                            extr_rows = []
                            extr_columns = []
                            for cell in [meet_twice_in_row[0][0], meet_twice_in_row[0][1], meet_twice_in_row[1][0], meet_twice_in_row[1][1], meet_twice_in_row[2][0], meet_twice_in_row[2][1]]:
                                if cell[0] not in extr_rows:
                                    extr_rows.append(cell[0])
                                if cell[1] not in extr_columns:
                                    extr_columns.append(cell[1])
                            try:
                                extr_rows = sorted(extr_rows)
                                extr_columns = sorted(extr_columns)
                            except:
                                pass
                            if not self.check_if_in_the_same_block_ext(extr_rows, extr_columns):
                                for g in range(9):
                                    if str(type(self.sudoku_table[g][extr_columns[0]]))=="<class 'list'>" and g not in [extr_rows[0], extr_rows[1], extr_rows[2]]:
                                        if k in self.sudoku_table[g][extr_columns[0]]:
                                            self.sudoku_table[g][extr_columns[0]].remove(int(k))
                                            self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {k} from list of p.n. in cell {self.letter_for_collumn(extr_columns[0])}{g+1} (due to swordfishing in columns {self.letter_for_collumn(extr_columns[0])}, {self.letter_for_collumn(extr_columns[1])} & {self.letter_for_collumn(extr_columns[2])})")
                                            self.action += 1
                                            table_changed, self.ch_gl, self.moderate = True, True, True
                                            self.uses["Swordfishing"] += 1
                                    if str(type(self.sudoku_table[g][extr_columns[1]]))=="<class 'list'>" and g not in [extr_rows[0], extr_rows[1], extr_rows[2]]:
                                        if k in self.sudoku_table[g][extr_columns[1]]:
                                            self.sudoku_table[g][extr_columns[1]].remove(int(k))
                                            self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {k} from list of p.n. in cell {self.letter_for_collumn(extr_columns[1])}{g+1} (due to swordfishing in columns {self.letter_for_collumn(extr_columns[0])}, {self.letter_for_collumn(extr_columns[1])} & {self.letter_for_collumn(extr_columns[2])})")
                                            self.action += 1
                                            table_changed, self.ch_gl, self.moderate = True, True, True
                                            self.uses["Swordfishing"] += 1
                                    if str(type(self.sudoku_table[g][extr_columns[2]]))=="<class 'list'>" and g not in [extr_rows[0], extr_rows[1], extr_rows[2]]:
                                        if k in self.sudoku_table[g][extr_columns[2]]:
                                            self.sudoku_table[g][extr_columns[2]].remove(int(k))
                                            self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {k} from list of p.n. in cell {self.letter_for_collumn(extr_columns[2])}{g+1} (due to swordfishing in columns {self.letter_for_collumn(extr_columns[0])}, {self.letter_for_collumn(extr_columns[1])} & {self.letter_for_collumn(extr_columns[2])})")
                                            self.action += 1
                                            table_changed, self.ch_gl, self.moderate = True, True, True
                                            self.uses["Swordfishing"] += 1

    def check_if_in_the_same_block(self, cell1, cell2, cell3, cell4):
        if cell1[0]//3 == cell2[0]//3 and cell1[0]//3 == cell3[0]//3 and cell1[0]//3 == cell4[0]//3 and cell2[0]//3 == cell3[0]//3 and cell2[0]//3 == cell4[0]//3 and cell3[0]//3 == cell4[0]//3:
            if cell1[1]//3 == cell2[1]//3 and cell1[1]//3 == cell3[1]//3 and cell1[1]//3 == cell4[1]//3 and cell2[1]//3 == cell3[1]//3 and cell2[1]//3 == cell4[1]//3 and cell3[1]//3 == cell4[1]//3:
                return True
            else:
                return False
        else:
            return False

    def check_if_in_the_same_block_ext(self, extr_rows, extr_columns):
        if extr_rows[0]//3 == extr_rows[2]//3:
            return True
        else:
            if extr_columns[0]//3 == extr_columns[2]//3:
                return True
            else:
                return False

    def y_wing(self):
        table_changed = True
        while table_changed and self.solvability == "possible":
            table_changed = False
            for cu, cd in ((cu, cd) for cu in range(8) for cd in range(cu + 1, 9)):
                for ru, rd in ((ru, rd) for ru in range(8) for rd in range(ru + 1, 9)):
                    if str(type(self.sudoku_table[ru][cu]))=="<class 'list'>" and str(type(self.sudoku_table[ru][cd]))=="<class 'list'>" and str(type(self.sudoku_table[rd][cu]))=="<class 'list'>" and str(type(self.sudoku_table[rd][cd]))=="<class 'list'>":
                        if not self.check_if_in_the_same_block([ru, cu], [ru, cd], [rd, cu], [rd, cd]):
                            if len(self.sudoku_table[ru][cu]) == 2 and len(self.sudoku_table[rd][cu]) == 2 and len(self.sudoku_table[rd][cd]) == 2 and len(self.sudoku_table[ru][cd]) >= 2:
                                if are_sync(self.sudoku_table[ru][cu], self.sudoku_table[rd][cu], self.sudoku_table[rd][cd]):
                                    if sorted(set(self.sudoku_table[ru][cu]) & set(self.sudoku_table[rd][cd]))[0] in self.sudoku_table[ru][cd]:
                                        self.sudoku_table[ru][cd].remove(int(sorted(set(self.sudoku_table[ru][cu]) & set(self.sudoku_table[rd][cd]))[0]))
                                        self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {sorted(set(self.sudoku_table[ru][cu]) & set(self.sudoku_table[rd][cd]))[0]} from list of p.n. in cell {self.letter_for_collumn(cd)}{ru+1} (due to y-winging)")
                                        self.action += 1
                                        table_changed, self.ch_gl, self.moderate = True, True, True
                                        self.uses["Y-wings"] += 1
                            if len(self.sudoku_table[ru][cu]) == 2 and len(self.sudoku_table[rd][cu]) == 2 and len(self.sudoku_table[ru][cd]) == 2 and len(self.sudoku_table[rd][cd]) >= 2:
                                if are_sync(self.sudoku_table[ru][cu], self.sudoku_table[rd][cu], self.sudoku_table[ru][cd]):
                                    if sorted(set(self.sudoku_table[ru][cd]) & set(self.sudoku_table[rd][cu]))[0] in self.sudoku_table[rd][cd]:
                                        self.sudoku_table[rd][cd].remove(int(sorted(set(self.sudoku_table[ru][cd]) & set(self.sudoku_table[rd][cu]))[0]))
                                        self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {sorted(set(self.sudoku_table[ru][cd]) & set(self.sudoku_table[rd][cu]))[0]} from list of p.n. in cell {self.letter_for_collumn(cd)}{rd+1} (due to y-winging)")
                                        self.action += 1
                                        table_changed, self.ch_gl, self.moderate = True, True, True
                                        self.uses["Y-wings"] += 1
                            if len(self.sudoku_table[rd][cu]) == 2 and len(self.sudoku_table[ru][cd]) == 2 and len(self.sudoku_table[rd][cd]) == 2 and len(self.sudoku_table[ru][cu]) >= 2:
                                if are_sync(self.sudoku_table[rd][cu], self.sudoku_table[ru][cd], self.sudoku_table[rd][cd]):
                                    if sorted(set(self.sudoku_table[ru][cd]) & set(self.sudoku_table[rd][cu]))[0] in self.sudoku_table[ru][cu]:
                                        self.sudoku_table[ru][cu].remove(int(sorted(set(self.sudoku_table[ru][cd]) & set(self.sudoku_table[rd][cu]))[0]))
                                        self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {sorted(set(self.sudoku_table[ru][cd]) & set(self.sudoku_table[rd][cu]))[0]} from list of p.n. in cell {self.letter_for_collumn(cu)}{ru+1} (due to y-winging)")
                                        self.action += 1
                                        table_changed, self.ch_gl, self.moderate = True, True, True
                                        self.uses["Y-wings"] += 1
                            if len(self.sudoku_table[ru][cu]) == 2 and len(self.sudoku_table[ru][cd]) == 2 and len(self.sudoku_table[rd][cd]) == 2 and len(self.sudoku_table[rd][cu]) >= 2:
                                if are_sync(self.sudoku_table[ru][cu], self.sudoku_table[ru][cd], self.sudoku_table[rd][cd]):
                                    if sorted(set(self.sudoku_table[ru][cu]) & set(self.sudoku_table[rd][cd]))[0] in self.sudoku_table[rd][cu]:
                                        self.sudoku_table[rd][cu].remove(int(sorted(set(self.sudoku_table[ru][cu]) & set(self.sudoku_table[rd][cd]))[0]))
                                        self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {sorted(set(self.sudoku_table[ru][cu]) & set(self.sudoku_table[rd][cd]))[0]} from list of p.n. in cell {self.letter_for_collumn(cu)}{rd+1} (due to y-winging)")
                                        self.action += 1
                                        table_changed, self.ch_gl, self.moderate = True, True, True
                                        self.uses["Y-wings"] += 1

    def asign_cell_num(self, row, collumn, num, wd):
        try:
            self.sudoku_table[row][collumn] = int(num)
            if self.called_by == "__call__":
                self.enter_numbers_solving_mode[int((row*9)+collumn)].place_forget()
                temp_label = Label(tk, text = f"{num}", bg = "light grey", fg = "black", font=("Calibri", 30))
                temp_label.place(x = 8 +(((row * 9) + collumn) - (((row * 9) + collumn)//9)*9)*55, y =  8 +(((row * 9) + collumn)//9)*55, width = 44, height = 44 )
            self.list_of_changes_solving_mode.append(f"#{self.action} - Asigned {num} to {self.letter_for_collumn(collumn)}{row+1} {wd}")
            self.action += 1
            self.clicka_num_remove(row, collumn, num, ["r", "c", "b"])
        except:
            print("Error")

    def clicka_num_remove(self, row, collumn, num, wd):
        if "c" in wd:
            for k in range(0, 9):
                if str(type(self.sudoku_table[k][collumn]))=="<class 'list'>":
                    try:
                        self.sudoku_table[k][collumn].remove(int(num))
                        self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {num} from list of possible numbers in cell {self.letter_for_collumn(collumn)}{k+1} (in collumn with {self.letter_for_collumn(collumn)}{row+1})")
                        self.action += 1
                    except:
                        pass
        if "r" in wd:
            for n in range(0, 9):
                if str(type(self.sudoku_table[row][n]))=="<class 'list'>":
                    try:
                        self.sudoku_table[row][n].remove(int(num))
                        self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {num} from list of possible numbers in cell {self.letter_for_collumn(n)}{row+1} (in row with {self.letter_for_collumn(collumn)}{row+1})")
                        self.action += 1
                    except:
                        pass
        if "b" in wd:
            block_row = ((row*9 + collumn)//27)*3
            block_collumn = (((row*9 + collumn)%9)//3)*3
            for l in range(0, 9):
                if str(type(self.sudoku_table[block_row+(l//3)][block_collumn+(l%3)]))=="<class 'list'>":
                    try:
                        self.sudoku_table[block_row+(l//3)][block_collumn+(l%3)].remove(int(num))
                        self.list_of_changes_solving_mode.append(f"#{self.action} --- Deleted {num} from list of possible numbers in cell {self.letter_for_collumn(block_collumn+(l%3))}{block_row+(l//3)+1} (in block with {self.letter_for_collumn(collumn)}{row+1})")
                        self.action += 1
                    except:
                        pass

    def build_sudoku(self):
        self.mode = "creation"
        self.cannot_be_deleted, self.solvability_build = [], True
        self.filled_cells = [9]*9
        self.sudoku_table_build = [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]]
        for k in range(0, 81):
            temp = self.enter_numbers_building_mode[k].get()
            if len(temp)>1 or len(temp)==0:
                self.solvability_build = False
                break
            elif len(temp) == 1:
                try:
                    f = int(temp)
                    if f != 0:
                        self.sudoku_table_build[k//9][k%9] = f
                    else:
                        self.solvability_build = False
                        break
                except:
                    self.solvability_build = False
                    break
        if self.check_if_correct(self.sudoku_table_build) and self.solvability_build:
            self.check_if_correct_for_building()
        else:
            self.solvability_build = False

    def generate_sudoku(self):
        self.mode = "generation"
        self.cannot_be_deleted = []
        self.filled_cells = [9]*9
        self.sudoku_table_build = [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]]
        self.sudoku_table_build = self.basic_backtracking(self.sudoku_table_build)
        self.check_if_correct_for_building()

    def check_if_correct_for_building(self):
        self.look_for_x_wing_trap()
        self.look_for_ideal_twins_trap()
        self.cannot_be_deleted = sorted(self.cannot_be_deleted)
        if self.difficulty_evaluation == "hints":
            self.build_cell_by_cell()
        elif self.difficulty_evaluation == "levels":
            self.build_cell_by_cell_alt()

    def build_cell_by_cell(self):
        save = [[copy.deepcopy(self.sudoku_table_build), "st", copy.deepcopy(self.cannot_be_deleted)]]
        possibility = True
        self.h = 0
        while sum(self.filled_cells) > max(int(self.enter_number_of_hints_building_mode.get()), 17, len(copy.deepcopy(self.cannot_be_deleted))): #and self.mode == "creation") or (max(int(self.enter_number_of_hints_building_mode.get()), 17, len(copy.deepcopy(self.cannot_be_deleted))) and self.mode == "generation" and self.h < 75):
            self.sudoku_table_build = copy.deepcopy(save[-1][0])
            cannot_be_deleted_temp = copy.deepcopy(save[-1][2])
            valid_numbers = [num for num in list(range(81)) if num not in copy.deepcopy(cannot_be_deleted_temp)]
            if len(valid_numbers) >= int(self.enter_number_of_hints_building_mode.get()):
                b = random.choice(valid_numbers)
                if str(type(self.sudoku_table_build[b//9][b%9]))=="<class 'int'>":
                    if len(copy.deepcopy(cannot_be_deleted_temp)) < sum(copy.deepcopy(self.filled_cells)):
                        deleted_num = copy.deepcopy(self.sudoku_table_build)[b//9][b%9]-1
                        self.filled_cells[deleted_num] += -1
                        if sum(1 for x in copy.deepcopy(self.filled_cells) if x == 0) < 2:
                            self.sudoku_table_build[b//9][b%9] = ""
                            save.append([copy.deepcopy(self.sudoku_table_build), b, copy.deepcopy(cannot_be_deleted_temp)])
                            self.h+=1
                            self.solve_sudoku()
                            if self.solved:
                                save[-1][2] = copy.deepcopy(save[0][2])
                            else:
                                self.filled_cells[deleted_num] += 1
                                save[-2][2].append(b)
                                save = copy.deepcopy(save[:-1])
                        else:
                            self.filled_cells[deleted_num] += 1
                            save[-1][2].append(b)
                    elif len(save[-1][2]) >= sum(self.filled_cells) and str(save[-1][1]) != "st":
                        deleted_num_b = save[1][0][save[-1][1]//9][save[-1][1]%9]-1
                        save[-2][2].append(save[-1][1])
                        save = copy.deepcopy(save[:-1])
                        self.filled_cells[deleted_num_b] += 1
                    elif len(save[-1][2]) >= sum(self.filled_cells) and str(save[-1][1]) == "st":
                        self.sudoku_table_build = copy.deepcopy(save[0][0])
                        possibility = False
                        break
            else:
                self.sudoku_table_build = copy.deepcopy(save[0][0])
                print(f"For this table is no build with {int(self.enter_number_of_hints_building_mode.get())} hints")
                possibility = False
                break
        if possibility:
            temp_label = Label(tk, text = f"Difficulty: {self.difficulty}", bg = "black", fg = "white", font=("Calibri", 10))
            temp_label.place(x = 500, y =  355, width = 200, height = 30 )
            self.sudoku_table_built_on_screen(save[-1][0])
        else:
            self.generate_sudoku()

    def build_cell_by_cell_alt(self):
        last_output = "easy"
        save = [[copy.deepcopy(self.sudoku_table_build), "st", copy.deepcopy(self.cannot_be_deleted)]]
        possibility = True
        self.h=0
        while (sum(self.filled_cells) > 17 and self.mode == "creation") or (sum(self.filled_cells) > 17 and self.mode == "generation" and self.h < 75):
            self.sudoku_table_build = copy.deepcopy(save[-1][0])
            cannot_be_deleted_temp = copy.deepcopy(save[-1][2])
            valid_numbers = [num for num in list(range(81)) if num not in copy.deepcopy(cannot_be_deleted_temp)]
            if len(valid_numbers) >= 17:
                b = random.choice(valid_numbers)
                if str(type(self.sudoku_table_build[b//9][b%9]))=="<class 'int'>":
                    if len(copy.deepcopy(cannot_be_deleted_temp)) < sum(copy.deepcopy(self.filled_cells)):
                        deleted_num = copy.deepcopy(self.sudoku_table_build)[b//9][b%9]-1
                        self.filled_cells[deleted_num] += -1
                        if sum(1 for x in copy.deepcopy(self.filled_cells) if x == 0) < 2:
                            self.sudoku_table_build[b//9][b%9] = ""
                            save.append([copy.deepcopy(self.sudoku_table_build), b, copy.deepcopy(cannot_be_deleted_temp)])
                            self.h+=1
                            self.solve_sudoku()
                            if self.solved:
                                save[-1][2] = copy.deepcopy(save[0][2])
                                if int(self.enter_number_of_hints_building_mode.get()) <= 1:
                                    if self.difficulty == "normal":
                                        temp_label = Label(tk, text = "Difficulty: easy", bg = "black", fg = "white", font=("Calibri", 10))
                                        temp_label.place(x = 500, y =  355, width = 200, height = 30 )
                                        self.sudoku_table_built_on_screen(save[-2][0])
                                        break
                                elif int(self.enter_number_of_hints_building_mode.get()) == 2:
                                    if self.difficulty == "normal":
                                        temp_label = Label(tk, text = "Difficulty: normal", bg = "black", fg = "white", font=("Calibri", 10))
                                        temp_label.place(x = 500, y =  355, width = 200, height = 30 )
                                        self.sudoku_table_built_on_screen(save[-1][0])
                                        break
                                elif int(self.enter_number_of_hints_building_mode.get()) >= 3:
                                    if self.difficulty == "hard":
                                        temp_label = Label(tk, text = "Difficulty: hard", bg = "black", fg = "white", font=("Calibri", 10))
                                        temp_label.place(x = 500, y =  355, width = 200, height = 30 )
                                        self.sudoku_table_built_on_screen(save[-1][0])
                                        break
                                last_output = self.difficulty
                            else:
                                if int(self.enter_number_of_hints_building_mode.get()) <= 1:
                                    temp_label = Label(tk, text = "Difficulty: easy", bg = "black", fg = "white", font=("Calibri", 10))
                                    temp_label.place(x = 500, y =  355, width = 200, height = 30 )
                                    self.sudoku_table_built_on_screen(save[-2][0])
                                    break
                                else:
                                    self.filled_cells[deleted_num] += 1
                                    save[-2][2].append(b)
                                    save = copy.deepcopy(save[:-1])
                        else:
                            self.filled_cells[deleted_num] += 1
                            save[-1][2].append(b)
                    elif len(save[-1][2]) >= sum(self.filled_cells) and str(save[-1][1]) != "st":
                        deleted_num_b = save[1][0][save[-1][1]//9][save[-1][1]%9]-1
                        save[-2][2].append(save[-1][1])
                        save = copy.deepcopy(save[:-1])
                        self.filled_cells[deleted_num_b] += 1
                    elif len(save[-1][2]) >= sum(self.filled_cells) and str(save[-1][1]) == "st":
                        self.sudoku_table_build = copy.deepcopy(save[0][0])
                        possibility = False
                        break
            else:
                self.sudoku_table_build = copy.deepcopy(save[0][0])
                possibility = False
                print(f"For this table is no build with {int(self.enter_number_of_hints_building_mode.get())} difficulty")
                break
        if possibility:
            if self.mode == "generation":
                if self.h < 75:
                    pass
                else:
                    self.generate_sudoku()
            else:
                pass

    def check_if_correct(self, lst):
        for (r, c) in product(range(9), repeat=2):
            if lst[r][c] != 0:
                allowed = True
                for i in range(9):
                    if (lst[i][c] == lst[r][c] and r != i) or (lst[r][i] == lst[r][c] and c != i):
                        allowed = False
                        break
                if allowed:
                    for (i, j) in product(range(3), repeat=2):
                        if lst[r - r % 3 + i][c - c % 3 + j] == lst[r][c] and (r != r - r % 3 + i or c != c - c % 3 + j):
                            allowed = False
                            break
                if not allowed:
                    break
            else:
                allowed = False
                break
        if allowed:
            return True
        else:
            return False   

    def basic_backtracking(self, lst):
        for (r, c) in product(range(9), repeat=2):
            if lst[r][c] == 0:
                numbers = list(range(1, 10))
                random.shuffle(numbers)
                for num in numbers:
                    allowed = True
                    for i in range(9):
                        if lst[i][c] == num or lst[r][i] == num:
                            allowed = False
                            break
                    if allowed:
                        for (i, j) in product(range(3), repeat=2):
                            if lst[r - r % 3 + i][c - c % 3 + j] == num:
                                allowed = False
                                break
                    if allowed:
                        lst[r][c] = num
                        if trial := self.basic_backtracking(lst):
                            return trial
                        lst[r][c] = 0
                return False
        return lst

    def letter_for_collumn(self, coll):
        if coll == 0:
            return "A"
        elif coll == 1:
            return "B"
        elif coll == 2:
            return "C"
        elif coll == 3:
            return "D"
        elif coll == 4:
            return "E"
        elif coll == 5:
            return "F"
        elif coll == 6:
            return "G"
        elif coll == 7:
            return "H"
        elif coll == 8:
            return "I"
        else:
            return "err"

    def sudoku_table_converted(self, table):
        output = ""
        for r in table:
            for i in r:
                if str(type(i))=="<class 'list'>":
                    output += f" [{len(i)}]"
                elif str(type(i))=="<class 'str'>":
                    output += f"  _ "
                else:
                    output += f"  {i} "
            output += "\n"
        return output

    def sudoku_table_built_on_screen(self, table):
        for r in range(9):
            for i in range(9):
                if str(type(table[r][i]))=="<class 'int'>":
                    temp_label = Label(tk, text = f"{table[r][i]}", bg = "light grey", fg = "black", font=("Calibri", 30))
                else:
                    temp_label = Label(tk, text = " ", bg = "white", fg = "black", font=("Calibri", 30))
                temp_label.place(x = 8 +(((r * 9) + i) - (((r * 9) + i)//9)*9)*55, y =  8 +(((r * 9) + i)//9)*55, width = 44, height = 44 )
        for t in range(81):
            self.enter_numbers_building_mode[-t-1].destroy()

    def look_for_x_wing_trap(self):
        traps, system_of_traps_break_point = [], []
        for cu, cd in ((cu, cd) for cu in range(8) for cd in range(cu + 1, 9)):
            for ru, rd in ((ru, rd) for ru in range(8) for rd in range(ru + 1, 9)):
                if self.sudoku_table_build[ru][cd] == self.sudoku_table_build[rd][cu] and self.sudoku_table_build[ru][cu] == self.sudoku_table_build[rd][cd] and (ru//3 == rd//3 or cu//3 == cd//3) and not (ru//3 == rd//3 and cu//3 == cd//3):
                    traps.append([(ru, cd), (rd, cu), (ru, cu), (rd, cd)])
        for f in range(len(traps)-1):
            for g in range(f+1, len(traps)):
                if len(list(set(traps[f]) & set(traps[g]))) == 1:
                    if len(system_of_traps_break_point)>0:
                        for it in range(len(system_of_traps_break_point)):
                            if f in system_of_traps_break_point[it] and g in system_of_traps_break_point[it]:
                                create_new_system = False
                                break
                            elif (f in system_of_traps_break_point[it] and g not in system_of_traps_break_point[it]) or (f not in system_of_traps_break_point[it] and g in system_of_traps_break_point[it]):
                                create_new_system = False
                                system_of_traps_break_point[it] = sorted(set(system_of_traps_break_point[it] + [f, g]))
                                break
                            else:
                                create_new_system = True
                        if create_new_system:
                            system_of_traps_break_point.append([f, g])
                    else:
                        system_of_traps_break_point.append([f, g])
        has_change = True
        while has_change and len(system_of_traps_break_point) > 1:
            has_change = False
            temp_copied = copy.deepcopy(system_of_traps_break_point)
            for f in range(len(temp_copied)-1):
                for g in range(f+1, len(temp_copied)):
                    if len(list(set(temp_copied[f]) & set(temp_copied[g]))) > 0:
                        system_of_traps_break_point.append(sorted(set(temp_copied[f] + temp_copied[g])))
                        del temp_copied[g]
                        del temp_copied[f]
                        has_change = True
                        break
            system_of_traps_break_point = copy.deepcopy(temp_copied)
        for its in system_of_traps_break_point:
            for f in range(len(its)-1):
                for g in range(f+1, len(its)):
                    if len(list(set(traps[its[f]]) & set(traps[its[g]]))) == 1:
                        for k in sorted(set(traps[its[f]]+traps[its[g]])):
                            if (9*k[0])+k[1] in self.cannot_be_deleted:
                                allowed = False
                                break
                            else:
                                allowed = True
                        if allowed:
                            self.cannot_be_deleted.append((9*list(set(traps[its[f]]) & set(traps[its[g]]))[0][0])+list(set(traps[its[f]]) & set(traps[its[g]]))[0][1])
        for index in range(len(traps)):
            if (9*traps[index][0][0])+traps[index][0][1] not in self.cannot_be_deleted and (9*traps[index][1][0])+traps[index][1][1] not in self.cannot_be_deleted and (9*traps[index][2][0])+traps[index][2][1] not in self.cannot_be_deleted and (9*traps[index][3][0])+traps[index][3][1] not in self.cannot_be_deleted:
                self.cannot_be_deleted.append((9*random.choice([traps[index][0][0], traps[index][1][0]]))+random.choice([traps[index][1][1], traps[index][0][1]]))

    def look_for_ideal_twins_trap(self):
        for cu, cm, cd in ((cu, cm, cd) for cu in range(7) for cm in range(cu + 1, 8) for cd in range(cm + 1, 9)):
            for ru, rm, rd in ((ru, rm, rd) for ru in range(7) for rm in range(ru + 1, 8) for rd in range(rm + 1, 9)):
                if (ru//3 == rd//3 and rm//3 == ru//3 and not (cu//3 == cd//3 or cu//3 == cm//3)) or (cu//3 == cd//3 and cu//3 == cm//3 and not(ru//3 == rd//3 or ru//3 == rm//3)):
                    temp_list, num_times = [[ru, cu], [ru, cm], [ru, cd], [rm, cu], [rm, cm], [rm, cd], [rd, cu], [rd, cm], [rd, cd]], [0, 0, 0, 0, 0, 0, 0, 0, 0]
                    for it in temp_list:
                        num_times[self.sudoku_table_build[it[0]][it[1]]-1] += 1
                    templist_upd = []
                    if sum(1 for x in num_times if x == 3) >= 2:
                        for its in range(len(num_times)):
                            templist = []
                            if num_times[its] == 3:
                                for k in temp_list:
                                    if self.sudoku_table_build[k[0]][k[1]] == its+1:
                                        templist.append(k)
                                templist_upd.append(templist)
                        if len(templist_upd) == 2:
                            for f, g in ((f, g) for f in range(len(templist_upd)) for g in range(len(templist_upd[f]))):
                                allowed = True
                                if (9*templist_upd[f][g][0])+templist_upd[f][g][1] in self.cannot_be_deleted:
                                    allowed = False
                                    break
                            if allowed:
                                a = random.choice(templist_upd[random.choice([0, 1])])
                                self.cannot_be_deleted.append((9*a[0])+a[1])
                        elif len(templist_upd) == 3:
                            for f, g in ((f, g) for f in range(len(templist_upd)) for g in range(len(templist_upd[f]))):
                                allowed = True
                                if (9*templist_upd[f][g][0])+templist_upd[f][g][1] in self.cannot_be_deleted:
                                    if (9*templist_upd[f][g][0])+templist_upd[f][g][1] in self.cannot_be_deleted:
                                        allowed = False
                                        del templist_upd[f]
                                        break
                            if allowed:
                                a = random.choice([0, 1, 2])
                                b = random.choice(list(set([0, 1, 2]) - set([a])))
                                random.choice(templist_upd[a])[0]
                                self.cannot_be_deleted.append((9*random.choice(templist_upd[a])[0])+random.choice(templist_upd[a])[1])
                                self.cannot_be_deleted.append((9*random.choice(templist_upd[b])[0])+random.choice(templist_upd[b])[1])
                            else:
                                for f, g in ((f, g) for f in range(len(templist_upd)) for g in range(len(templist_upd[f]))):
                                    allowed_s = True
                                    if (9*templist_upd[f][g][0])+templist_upd[f][g][1] in self.cannot_be_deleted:
                                        allowed_s = False
                                        break
                                if allowed_s:
                                    a = random.choice(templist_upd[random.choice([0, 1])])
                                    self.cannot_be_deleted.append((9*a[0])+a[1])

if __name__=='__main__':
    tk = Tk()
    tk.title('Sudoku Solver')
    tk.geometry('685x705+0+0')
    tk['bg'] = 'black'
    Sudoku_main_work()
    tk.mainloop()
